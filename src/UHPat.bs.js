// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';

var Block = require("bs-platform/lib/js/block.js");
var Pervasives = require("bs-platform/lib/js/pervasives.js");
var Caml_exceptions = require("bs-platform/lib/js/caml_exceptions.js");
var OpSeq$Extraction = require("./OpSeq.bs.js");
var MetaVarGen$Extraction = require("./MetaVarGen.bs.js");

var FreeVarInPat = Caml_exceptions.create("UHPat-Extraction.FreeVarInPat");

function string_of_operator(param) {
  switch (param) {
    case /* Comma */0 :
        return ",";
    case /* Space */1 :
        return " ";
    case /* Cons */2 :
        return "::";
    
  }
}

function is_Space(param) {
  return param === 1;
}

function is_Comma(param) {
  return param === 0;
}

function $$var($staropt$star, $staropt$star$1, x) {
  var err = $staropt$star !== undefined ? $staropt$star : /* NotInHole */0;
  var var_err = $staropt$star$1 !== undefined ? $staropt$star$1 : /* NotInVarHole */0;
  return /* Var */Block.__(2, [
            err,
            var_err,
            x
          ]);
}

function wild($staropt$star, param) {
  var err = $staropt$star !== undefined ? $staropt$star : /* NotInHole */0;
  return /* Wild */Block.__(1, [err]);
}

function boollit($staropt$star, b) {
  var err = $staropt$star !== undefined ? $staropt$star : /* NotInHole */0;
  return /* BoolLit */Block.__(4, [
            err,
            b
          ]);
}

function numlit($staropt$star, n) {
  var err = $staropt$star !== undefined ? $staropt$star : /* NotInHole */0;
  return /* NumLit */Block.__(3, [
            err,
            n
          ]);
}

function listnil($staropt$star, param) {
  var err = $staropt$star !== undefined ? $staropt$star : /* NotInHole */0;
  return /* ListNil */Block.__(5, [err]);
}

function get_tuple_elements(skel) {
  if (skel.tag && skel[1] === 0) {
    return Pervasives.$at(get_tuple_elements(skel[2]), get_tuple_elements(skel[3]));
  } else {
    return /* :: */[
            skel,
            /* [] */0
          ];
  }
}

function make_tuple(err, elements) {
  if (elements) {
    var skels = elements[1];
    var skel = elements[0];
    if (skels) {
      return /* BinOp */Block.__(1, [
                err,
                /* Comma */0,
                skel,
                make_tuple(/* NotInHole */0, skels)
              ]);
    } else {
      return skel;
    }
  } else {
    return Pervasives.failwith("make_tuple: expected at least 1 element");
  }
}

function new_EmptyHole(u_gen) {
  var match = MetaVarGen$Extraction.next(u_gen);
  return /* tuple */[
          /* EmptyHole */Block.__(0, [match[0]]),
          match[1]
        ];
}

function is_EmptyHole(param) {
  if (param.tag) {
    return false;
  } else {
    return true;
  }
}

function get_err_status_operand(param) {
  switch (param.tag | 0) {
    case /* EmptyHole */0 :
        return /* NotInHole */0;
    case /* Parenthesized */6 :
        return OpSeq$Extraction.get_err_status(get_err_status_operand, param[0]);
    default:
      return param[0];
  }
}

function get_err_status(p) {
  return OpSeq$Extraction.get_err_status(get_err_status_operand, p);
}

function get_err_status_opseq(opseq) {
  return OpSeq$Extraction.get_err_status(get_err_status_operand, opseq);
}

function set_err_status_operand(err, operand) {
  switch (operand.tag | 0) {
    case /* EmptyHole */0 :
        return operand;
    case /* Wild */1 :
        return /* Wild */Block.__(1, [err]);
    case /* Var */2 :
        return /* Var */Block.__(2, [
                  err,
                  operand[1],
                  operand[2]
                ]);
    case /* NumLit */3 :
        return /* NumLit */Block.__(3, [
                  err,
                  operand[1]
                ]);
    case /* BoolLit */4 :
        return /* BoolLit */Block.__(4, [
                  err,
                  operand[1]
                ]);
    case /* ListNil */5 :
        return /* ListNil */Block.__(5, [err]);
    case /* Parenthesized */6 :
        return /* Parenthesized */Block.__(6, [OpSeq$Extraction.set_err_status(set_err_status_operand, err, operand[0])]);
    case /* Inj */7 :
        return /* Inj */Block.__(7, [
                  err,
                  operand[1],
                  operand[2]
                ]);
    
  }
}

function set_err_status(err, p) {
  return OpSeq$Extraction.set_err_status(set_err_status_operand, err, p);
}

function set_err_status_opseq(err, opseq) {
  return OpSeq$Extraction.set_err_status(set_err_status_operand, err, opseq);
}

function is_inconsistent(p) {
  var match = OpSeq$Extraction.get_err_status(get_err_status_operand, p);
  if (match && !match[0]) {
    return true;
  } else {
    return false;
  }
}

function make_inconsistent_operand(u_gen, operand) {
  switch (operand.tag | 0) {
    case /* EmptyHole */0 :
        return /* tuple */[
                operand,
                u_gen
              ];
    case /* Wild */1 :
        var match = operand[0];
        if (match && !match[0]) {
          return /* tuple */[
                  operand,
                  u_gen
                ];
        }
        break;
    case /* Var */2 :
        var match$1 = operand[0];
        if (match$1 && !match$1[0]) {
          return /* tuple */[
                  operand,
                  u_gen
                ];
        }
        break;
    case /* NumLit */3 :
        var match$2 = operand[0];
        if (match$2 && !match$2[0]) {
          return /* tuple */[
                  operand,
                  u_gen
                ];
        }
        break;
    case /* BoolLit */4 :
        var match$3 = operand[0];
        if (match$3 && !match$3[0]) {
          return /* tuple */[
                  operand,
                  u_gen
                ];
        }
        break;
    case /* ListNil */5 :
        var match$4 = operand[0];
        if (match$4 && !match$4[0]) {
          return /* tuple */[
                  operand,
                  u_gen
                ];
        }
        break;
    case /* Parenthesized */6 :
        var match$5 = OpSeq$Extraction.make_inconsistent(make_inconsistent_operand, u_gen, operand[0]);
        return /* tuple */[
                /* Parenthesized */Block.__(6, [match$5[0]]),
                match$5[1]
              ];
    case /* Inj */7 :
        var match$6 = operand[0];
        if (match$6 && !match$6[0]) {
          return /* tuple */[
                  operand,
                  u_gen
                ];
        }
        break;
    
  }
  var match$7 = MetaVarGen$Extraction.next(u_gen);
  var set_operand = set_err_status_operand(/* InHole */[
        /* TypeInconsistent */0,
        match$7[0]
      ], operand);
  return /* tuple */[
          set_operand,
          match$7[1]
        ];
}

function make_inconsistent(u_gen, p) {
  return OpSeq$Extraction.make_inconsistent(make_inconsistent_operand, u_gen, p);
}

function make_inconsistent_opseq(u_gen, opseq) {
  return OpSeq$Extraction.make_inconsistent(make_inconsistent_operand, u_gen, opseq);
}

exports.FreeVarInPat = FreeVarInPat;
exports.string_of_operator = string_of_operator;
exports.is_Space = is_Space;
exports.is_Comma = is_Comma;
exports.$$var = $$var;
exports.wild = wild;
exports.boollit = boollit;
exports.numlit = numlit;
exports.listnil = listnil;
exports.get_tuple_elements = get_tuple_elements;
exports.make_tuple = make_tuple;
exports.new_EmptyHole = new_EmptyHole;
exports.is_EmptyHole = is_EmptyHole;
exports.get_err_status = get_err_status;
exports.get_err_status_opseq = get_err_status_opseq;
exports.get_err_status_operand = get_err_status_operand;
exports.set_err_status = set_err_status;
exports.set_err_status_opseq = set_err_status_opseq;
exports.set_err_status_operand = set_err_status_operand;
exports.is_inconsistent = is_inconsistent;
exports.make_inconsistent = make_inconsistent;
exports.make_inconsistent_opseq = make_inconsistent_opseq;
exports.make_inconsistent_operand = make_inconsistent_operand;
/* No side effect */

// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';

var Block = require("bs-platform/lib/js/block.js");
var Pervasives = require("bs-platform/lib/js/pervasives.js");
var Extraction_tool$Extraction = require("./Extraction_tool.bs.js");

function pass_apply(_t1, _t2) {
  while(true) {
    var t2 = _t2;
    var t1 = _t1;
    if (typeof t1 === "number" || t1.tag !== /* ARROW */1) {
      return /* CONFLICT */6;
    } else {
      var con = t1[1];
      var pre = t1[0];
      if (typeof t2 === "number") {
        switch (t2) {
          case /* HOLE */0 :
              return /* HOLE */0;
          case /* EMPTY */4 :
          case /* UNK */5 :
          case /* CONFLICT */6 :
              return /* CONFLICT */6;
          default:
            if (pass_apply_eq(pre, t2)) {
              return con;
            } else {
              return /* CONFLICT */6;
            }
        }
      } else if (t2.tag === /* ARROW */1) {
        if (pass_apply_eq(pre, t2[0])) {
          _t2 = t2[1];
          _t1 = con;
          continue ;
        } else {
          return /* CONFLICT */6;
        }
      } else if (pass_apply_eq(pre, t2)) {
        return con;
      } else {
        return /* CONFLICT */6;
      }
    }
  };
}

function pass_apply_eq(_t1, _t2) {
  while(true) {
    var t2 = _t2;
    var t1 = _t1;
    if (typeof t1 === "number") {
      switch (t1) {
        case /* Bool */1 :
            if (typeof t2 === "number") {
              return t2 === 1;
            } else {
              return false;
            }
        case /* Number */2 :
            if (typeof t2 === "number") {
              return t2 === 2;
            } else {
              return false;
            }
        case /* Unit */3 :
            if (typeof t2 === "number") {
              return t2 === 3;
            } else {
              return false;
            }
        case /* UNK */5 :
            return true;
        default:
          return false;
      }
    } else {
      switch (t1.tag | 0) {
        case /* List */0 :
            if (typeof t2 === "number" || t2.tag) {
              return false;
            } else {
              _t2 = t2[0];
              _t1 = t1[0];
              continue ;
            }
        case /* SUM */2 :
            if (typeof t2 === "number" || !(t2.tag === /* SUM */2 && pass_apply_eq(t1[0], t2[0]))) {
              return false;
            } else {
              _t2 = t2[1];
              _t1 = t1[1];
              continue ;
            }
        case /* PROD */3 :
            if (typeof t2 === "number" || !(t2.tag === /* PROD */3 && pass_apply_eq(t1[0], t2[0]))) {
              return false;
            } else {
              _t2 = t2[1];
              _t1 = t1[1];
              continue ;
            }
        default:
          return false;
      }
    }
  };
}

function pass_list(t1, t2) {
  var exit = 0;
  var exit$1 = 0;
  if (typeof t1 === "number" && t1 === 0) {
    return /* HOLE */0;
  } else {
    exit$1 = 3;
  }
  if (exit$1 === 3) {
    if (typeof t2 === "number" || t2.tag) {
      exit = 2;
    } else {
      var match = t2[0];
      if (typeof match === "number" && match === 0) {
        return /* HOLE */0;
      } else {
        exit = 2;
      }
    }
  }
  if (exit === 2 && typeof t1 === "number" && t1 === 5) {
    return /* CONFLICT */6;
  }
  if (typeof t2 === "number" || t2.tag) {
    return /* CONFLICT */6;
  } else {
    var b = t2[0];
    var match$1 = Extraction_tool$Extraction.pass_check(b, t1);
    if (typeof match$1 === "number") {
      if (match$1 !== 0) {
        if (match$1 >= 4) {
          return /* CONFLICT */6;
        } else {
          return /* List */Block.__(0, [Extraction_tool$Extraction.pass_check(b, t1)]);
        }
      } else {
        return /* HOLE */0;
      }
    } else {
      return /* List */Block.__(0, [Extraction_tool$Extraction.pass_check(b, t1)]);
    }
  }
}

function uhpat_trans(t, vs) {
  return uhpat_seq_trans(t[1], vs);
}

function uhpat_seq_trans(t, vs) {
  var affix_e = t[1];
  var operand = t[0];
  if (affix_e) {
    return uhpat_const(operand, affix_e[0], uhpat_seq_trans(affix_e[1], vs), vs);
  } else {
    return uhpat_operand_trans(operand, vs);
  }
}

function uhpat_operand_trans(ope, vs) {
  switch (ope.tag | 0) {
    case /* EmptyHole */0 :
        return /* tuple */[
                undefined,
                /* HOLE */0
              ];
    case /* Wild */1 :
        if (ope[0]) {
          return /* tuple */[
                  undefined,
                  /* HOLE */0
                ];
        } else {
          return /* tuple */[
                  "_",
                  /* UNK */5
                ];
        }
    case /* Var */2 :
        var $$var = ope[2];
        if (ope[0] || ope[1]) {
          return /* tuple */[
                  undefined,
                  /* HOLE */0
                ];
        } else {
          return /* tuple */[
                  $$var,
                  Extraction_tool$Extraction.find_variable_set($$var, vs)
                ];
        }
    case /* NumLit */3 :
        if (ope[0]) {
          return /* tuple */[
                  undefined,
                  /* HOLE */0
                ];
        } else {
          return /* tuple */[
                  String(ope[1]),
                  /* Number */2
                ];
        }
    case /* BoolLit */4 :
        if (ope[0]) {
          return /* tuple */[
                  undefined,
                  /* HOLE */0
                ];
        } else {
          return /* tuple */[
                  Pervasives.string_of_bool(ope[1]),
                  /* Bool */1
                ];
        }
    case /* ListNil */5 :
        if (ope[0]) {
          return /* tuple */[
                  undefined,
                  /* HOLE */0
                ];
        } else {
          return /* tuple */[
                  "[]",
                  /* List */Block.__(0, [/* UNK */5])
                ];
        }
    case /* Parenthesized */6 :
        return Extraction_tool$Extraction.extract_t_concat(/* :: */[
                    /* tuple */[
                      "(",
                      /* UNK */5
                    ],
                    /* :: */[
                      uhpat_trans(ope[0], vs),
                      /* :: */[
                        /* tuple */[
                          ")",
                          /* UNK */5
                        ],
                        /* [] */0
                      ]
                    ]
                  ]);
    case /* Inj */7 :
        var match = uhpat_trans(ope[2], vs);
        if (ope[0]) {
          return /* tuple */[
                  undefined,
                  /* HOLE */0
                ];
        } else {
          var match$1 = match[1];
          var s = match[0];
          if (typeof match$1 === "number" || match$1.tag !== /* SUM */2) {
            return /* tuple */[
                    undefined,
                    /* CONFLICT */6
                  ];
          } else if (ope[1]) {
            return /* tuple */[
                    s,
                    match$1[1]
                  ];
          } else {
            return /* tuple */[
                    s,
                    match$1[0]
                  ];
          }
        }
    
  }
}

function uhpat_const(ope1, op, ope2, vs) {
  var match = uhpat_operand_trans(ope1, vs);
  var p2 = ope2[1];
  var s2 = ope2[0];
  var p1 = match[1];
  var s1 = match[0];
  switch (op) {
    case /* Comma */0 :
        return /* tuple */[
                Extraction_tool$Extraction.option_string_concat(/* :: */[
                      s1,
                      /* :: */[
                        ",",
                        /* :: */[
                          s2,
                          /* [] */0
                        ]
                      ]
                    ]),
                /* PROD */Block.__(3, [
                    p1,
                    p2
                  ])
              ];
    case /* Space */1 :
        return /* tuple */[
                Extraction_tool$Extraction.option_string_concat(/* :: */[
                      s1,
                      /* :: */[
                        " ",
                        /* :: */[
                          s2,
                          /* [] */0
                        ]
                      ]
                    ]),
                pass_apply(p1, p2)
              ];
    case /* Cons */2 :
        return /* tuple */[
                Extraction_tool$Extraction.option_string_concat(/* :: */[
                      s1,
                      /* :: */[
                        "::",
                        /* :: */[
                          s2,
                          /* [] */0
                        ]
                      ]
                    ]),
                pass_list(p1, p2)
              ];
    
  }
}

exports.pass_apply = pass_apply;
exports.pass_apply_eq = pass_apply_eq;
exports.pass_list = pass_list;
exports.uhpat_trans = uhpat_trans;
exports.uhpat_seq_trans = uhpat_seq_trans;
exports.uhpat_operand_trans = uhpat_operand_trans;
exports.uhpat_const = uhpat_const;
/* No side effect */

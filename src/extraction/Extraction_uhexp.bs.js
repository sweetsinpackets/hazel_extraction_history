// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';

var Block = require("bs-platform/lib/js/block.js");
var Pervasives = require("bs-platform/lib/js/pervasives.js");
var UHExp$Extraction = require("../UHExp.bs.js");
var Extraction_tool$Extraction = require("./Extraction_tool.bs.js");
var Extraction_trans$Extraction = require("./Extraction_trans.bs.js");
var Extraction_uhpat$Extraction = require("./Extraction_uhpat.bs.js");
var Extraction_uhtyp$Extraction = require("./Extraction_uhtyp.bs.js");

function uhexp_trans(t, vs) {
  if (t) {
    var t$1 = t[1];
    var l = t[0];
    if (t$1) {
      var res = line_trans(l, vs);
      return Extraction_tool$Extraction.extract_t_combine(Extraction_tool$Extraction.extract_t_combine(res[0], /* tuple */[
                      "\n",
                      /* UNK */5
                    ]), uhexp_trans(t$1, res[1]));
    } else {
      return Extraction_tool$Extraction.extract_t_combine(line_trans(l, vs)[0], /* tuple */[
                  "\n",
                  /* UNK */5
                ]);
    }
  } else {
    return /* tuple */[
            "",
            /* UNK */5
          ];
  }
}

function line_trans(l, vs) {
  if (typeof l === "number") {
    return /* tuple */[
            /* tuple */[
              "",
              /* UNK */5
            ],
            vs
          ];
  } else if (l.tag) {
    return /* tuple */[
            uhexp_seq_trans(l[0][1], vs),
            vs
          ];
  } else {
    var uht_h2N = Extraction_tool$Extraction.hole_to_none(l[1]);
    var p_000 = Extraction_uhpat$Extraction.uhpat_trans(l[0], vs)[0];
    var p = /* tuple */[
      p_000,
      /* UNK */5
    ];
    var exp = uhexp_trans(l[2], vs);
    if (uht_h2N !== undefined) {
      var typ = Extraction_uhtyp$Extraction.uhtyp_trans(uht_h2N);
      var new_vs = Extraction_tool$Extraction.add_variable(/* tuple */[
            p_000,
            typ[1]
          ], vs);
      var e = Extraction_tool$Extraction.extract_t_concat(/* :: */[
            /* tuple */[
              "let ",
              /* UNK */5
            ],
            /* :: */[
              /* tuple */[
                "(",
                /* UNK */5
              ],
              /* :: */[
                p,
                /* :: */[
                  /* tuple */[
                    ":",
                    /* UNK */5
                  ],
                  /* :: */[
                    /* tuple */[
                      typ[0],
                      /* UNK */5
                    ],
                    /* :: */[
                      /* tuple */[
                        ")",
                        /* UNK */5
                      ],
                      /* :: */[
                        /* tuple */[
                          " = ",
                          /* UNK */5
                        ],
                        /* :: */[
                          /* tuple */[
                            exp[0],
                            /* UNK */5
                          ],
                          /* :: */[
                            /* tuple */[
                              " in ",
                              /* UNK */5
                            ],
                            /* [] */0
                          ]
                        ]
                      ]
                    ]
                  ]
                ]
              ]
            ]
          ]);
      return /* tuple */[
              e,
              new_vs
            ];
    } else {
      var new_vs$1 = Extraction_tool$Extraction.add_variable(/* tuple */[
            p_000,
            exp[1]
          ], vs);
      var e$1 = Extraction_tool$Extraction.extract_t_concat(/* :: */[
            /* tuple */[
              "let ",
              /* UNK */5
            ],
            /* :: */[
              /* tuple */[
                "(",
                /* UNK */5
              ],
              /* :: */[
                p,
                /* :: */[
                  /* tuple */[
                    ":",
                    /* UNK */5
                  ],
                  /* :: */[
                    /* tuple */[
                      Extraction_trans$Extraction.pass_trans(exp[1]),
                      /* UNK */5
                    ],
                    /* :: */[
                      /* tuple */[
                        ")",
                        /* UNK */5
                      ],
                      /* :: */[
                        /* tuple */[
                          " = ",
                          /* UNK */5
                        ],
                        /* :: */[
                          /* tuple */[
                            exp[0],
                            /* UNK */5
                          ],
                          /* :: */[
                            /* tuple */[
                              " in ",
                              /* UNK */5
                            ],
                            /* [] */0
                          ]
                        ]
                      ]
                    ]
                  ]
                ]
              ]
            ]
          ]);
      return /* tuple */[
              e$1,
              new_vs$1
            ];
    }
  }
}

function uhexp_seq_trans(t, vs) {
  var affix_e = t[1];
  var operand = t[0];
  if (affix_e) {
    return uhexp_const(operand, affix_e[0], uhexp_seq_trans(affix_e[1], vs), vs);
  } else {
    return uhexp_operand_trans(operand, vs);
  }
}

function uhexp_operand_trans(ope, vs) {
  switch (ope.tag | 0) {
    case /* EmptyHole */0 :
        return /* tuple */[
                "",
                /* HOLE */0
              ];
    case /* Var */1 :
        if (ope[0] || ope[1]) {
          return /* tuple */[
                  "",
                  /* HOLE */0
                ];
        } else {
          return Extraction_trans$Extraction.var_annotate(ope[2], vs);
        }
    case /* NumLit */2 :
        if (ope[0]) {
          return /* tuple */[
                  "",
                  /* HOLE */0
                ];
        } else {
          return /* tuple */[
                  String(ope[1]),
                  /* Number */2
                ];
        }
    case /* BoolLit */3 :
        if (ope[0]) {
          return /* tuple */[
                  "",
                  /* HOLE */0
                ];
        } else {
          return /* tuple */[
                  Pervasives.string_of_bool(ope[1]),
                  /* Bool */1
                ];
        }
    case /* ListNil */4 :
        if (ope[0]) {
          return /* tuple */[
                  "",
                  /* HOLE */0
                ];
        } else {
          return /* tuple */[
                  "[]",
                  /* List */Block.__(0, [/* UNK */5])
                ];
        }
    case /* Lam */5 :
        if (ope[0]) {
          return /* tuple */[
                  "",
                  /* HOLE */0
                ];
        } else {
          return lam_trans(ope[1], ope[2], ope[3], vs);
        }
    case /* Inj */6 :
        if (ope[0]) {
          return /* tuple */[
                  "",
                  /* HOLE */0
                ];
        } else {
          return inj_trans(ope[1], ope[2], vs);
        }
    case /* Case */7 :
        if (ope[0]) {
          return /* tuple */[
                  "",
                  /* HOLE */0
                ];
        } else {
          return case_trans(ope[1], ope[2], ope[3], vs);
        }
    case /* Parenthesized */8 :
        return Extraction_tool$Extraction.extract_t_concat(/* :: */[
                    /* tuple */[
                      "(",
                      /* UNK */5
                    ],
                    /* :: */[
                      uhexp_trans(ope[0], vs),
                      /* :: */[
                        /* tuple */[
                          ")",
                          /* UNK */5
                        ],
                        /* [] */0
                      ]
                    ]
                  ]);
    case /* ApPalette */9 :
        return /* tuple */[
                "ApPalette not implemented",
                /* CONFLICT */6
              ];
    
  }
}

function lam_trans(uhp, uht, t, vs) {
  var uht_h2N = Extraction_tool$Extraction.hole_to_none(uht);
  if (uht_h2N !== undefined) {
    var v_000 = Extraction_uhpat$Extraction.uhpat_trans(uhp, vs)[0];
    var x_t = Extraction_uhtyp$Extraction.uhtyp_trans(uht_h2N);
    var new_vs = Extraction_tool$Extraction.add_variable(/* tuple */[
          v_000,
          x_t[1]
        ], vs);
    var e_t = uhexp_trans(t, new_vs);
    var str = Extraction_tool$Extraction.option_string_concat(/* :: */[
          "(fun ",
          /* :: */[
            "(",
            /* :: */[
              v_000,
              /* :: */[
                ":",
                /* :: */[
                  x_t[0],
                  /* :: */[
                    ")",
                    /* :: */[
                      " -> ",
                      /* :: */[
                        e_t[0],
                        /* :: */[
                          ")",
                          /* [] */0
                        ]
                      ]
                    ]
                  ]
                ]
              ]
            ]
          ]
        ]);
    return /* tuple */[
            str,
            /* ARROW */Block.__(1, [
                x_t[1],
                e_t[1]
              ])
          ];
  } else {
    var v_000$1 = Extraction_uhpat$Extraction.uhpat_trans(uhp, vs)[0];
    var new_vs$1 = Extraction_tool$Extraction.add_variable(/* tuple */[
          v_000$1,
          /* UNK */5
        ], vs);
    var e_t$1 = uhexp_trans(t, new_vs$1);
    var str$1 = Extraction_tool$Extraction.option_string_concat(/* :: */[
          "(fun ",
          /* :: */[
            "(",
            /* :: */[
              v_000$1,
              /* :: */[
                ":",
                /* :: */[
                  "'a",
                  /* :: */[
                    ")",
                    /* :: */[
                      " -> ",
                      /* :: */[
                        e_t$1[0],
                        /* :: */[
                          ")",
                          /* [] */0
                        ]
                      ]
                    ]
                  ]
                ]
              ]
            ]
          ]
        ]);
    return /* tuple */[
            str$1,
            /* ARROW */Block.__(1, [
                /* UNK */5,
                e_t$1[1]
              ])
          ];
  }
}

function inj_trans(side, t, vs) {
  var exp = uhexp_trans(t, vs);
  var match = exp[1];
  if (typeof match === "number" || match.tag !== /* SUM */2) {
    return /* tuple */[
            "Not a sum type",
            /* CONFLICT */6
          ];
  } else if (side) {
    return /* tuple */[
            exp[0],
            match[1]
          ];
  } else {
    return /* tuple */[
            exp[0],
            match[0]
          ];
  }
}

function case_trans(t, rules, uht, vs) {
  var uht_h2N = Extraction_tool$Extraction.hole_to_none(uht);
  var x = uhexp_trans(t, vs);
  var r = rules_trans(x[1], rules, uht_h2N, vs);
  return Extraction_tool$Extraction.extract_t_concat(/* :: */[
              /* tuple */[
                "((match ",
                /* UNK */5
              ],
              /* :: */[
                /* tuple */[
                  x[0],
                  /* UNK */5
                ],
                /* :: */[
                  /* tuple */[
                    " with\n",
                    /* UNK */5
                  ],
                  /* :: */[
                    r,
                    /* :: */[
                      /* tuple */[
                        ") : ",
                        /* UNK */5
                      ],
                      /* :: */[
                        /* tuple */[
                          Extraction_trans$Extraction.pass_trans(r[1]),
                          /* UNK */5
                        ],
                        /* :: */[
                          /* tuple */[
                            ")",
                            /* UNK */5
                          ],
                          /* [] */0
                        ]
                      ]
                    ]
                  ]
                ]
              ]
            ]);
}

function rules_trans(x_t, rules, uht, vs) {
  var ext;
  if (rules) {
    var t = rules[1];
    var h = rules[0];
    ext = t ? Extraction_tool$Extraction.extract_t_combine(rule_trans(x_t, h, vs), rules_trans(x_t, t, uht, vs)) : rule_trans(x_t, h, vs);
  } else {
    ext = /* tuple */[
      "",
      /* UNK */5
    ];
  }
  if (uht !== undefined) {
    return Extraction_tool$Extraction.extract_t_combine(ext, /* tuple */[
                "",
                Extraction_uhtyp$Extraction.uhtyp_trans(uht)[1]
              ]);
  } else {
    return ext;
  }
}

function rule_trans(x_t, rule, vs) {
  var pat = Extraction_uhpat$Extraction.uhpat_trans(rule[0], vs);
  var typ = Extraction_tool$Extraction.pass_check(pat[1], x_t);
  if (typeof typ === "number") {
    if (typ !== 0) {
      if (typ >= 6) {
        return /* tuple */[
                "Pattern not match",
                /* CONFLICT */6
              ];
      }
      
    } else {
      return /* tuple */[
              undefined,
              /* HOLE */0
            ];
    }
  }
  return Extraction_tool$Extraction.extract_t_concat(/* :: */[
              /* tuple */[
                " | ",
                /* UNK */5
              ],
              /* :: */[
                /* tuple */[
                  pat[0],
                  /* UNK */5
                ],
                /* :: */[
                  /* tuple */[
                    " -> ",
                    /* UNK */5
                  ],
                  /* :: */[
                    uhexp_trans(rule[1], vs),
                    /* :: */[
                      /* tuple */[
                        "\n",
                        /* UNK */5
                      ],
                      /* [] */0
                    ]
                  ]
                ]
              ]
            ]);
}

function uhexp_const(ope1, op, ope2, vs) {
  var op1 = uhexp_operand_trans(ope1, vs);
  var str = Extraction_tool$Extraction.option_string_concat(/* :: */[
        op1[0],
        /* :: */[
          UHExp$Extraction.string_of_operator(op),
          /* :: */[
            ope2[0],
            /* [] */0
          ]
        ]
      ]);
  switch (op) {
    case /* Space */0 :
        return /* tuple */[
                str,
                Extraction_uhpat$Extraction.pass_apply(op1[1], ope2[1])
              ];
    case /* Plus */1 :
        var match = Extraction_tool$Extraction.pass_check(op1[1], ope2[1]);
        if (typeof match === "number" && match < 3) {
          switch (match) {
            case /* HOLE */0 :
                return /* tuple */[
                        undefined,
                        /* HOLE */0
                      ];
            case /* Bool */1 :
                return /* tuple */[
                        undefined,
                        /* CONFLICT */6
                      ];
            case /* Number */2 :
                return /* tuple */[
                        str,
                        /* Number */2
                      ];
            
          }
        } else {
          return /* tuple */[
                  undefined,
                  /* CONFLICT */6
                ];
        }
    case /* Minus */2 :
        var match$1 = Extraction_tool$Extraction.pass_check(op1[1], ope2[1]);
        if (typeof match$1 === "number" && match$1 < 3) {
          switch (match$1) {
            case /* HOLE */0 :
                return /* tuple */[
                        undefined,
                        /* HOLE */0
                      ];
            case /* Bool */1 :
                return /* tuple */[
                        undefined,
                        /* CONFLICT */6
                      ];
            case /* Number */2 :
                return /* tuple */[
                        str,
                        /* Number */2
                      ];
            
          }
        } else {
          return /* tuple */[
                  undefined,
                  /* CONFLICT */6
                ];
        }
    case /* Times */3 :
        var match$2 = Extraction_tool$Extraction.pass_check(op1[1], ope2[1]);
        if (typeof match$2 === "number" && match$2 < 3) {
          switch (match$2) {
            case /* HOLE */0 :
                return /* tuple */[
                        undefined,
                        /* HOLE */0
                      ];
            case /* Bool */1 :
                return /* tuple */[
                        undefined,
                        /* CONFLICT */6
                      ];
            case /* Number */2 :
                return /* tuple */[
                        str,
                        /* Number */2
                      ];
            
          }
        } else {
          return /* tuple */[
                  undefined,
                  /* CONFLICT */6
                ];
        }
    case /* LessThan */4 :
        var match$3 = Extraction_tool$Extraction.pass_check(op1[1], ope2[1]);
        if (typeof match$3 === "number" && match$3 < 3) {
          switch (match$3) {
            case /* HOLE */0 :
                return /* tuple */[
                        undefined,
                        /* HOLE */0
                      ];
            case /* Bool */1 :
                return /* tuple */[
                        undefined,
                        /* CONFLICT */6
                      ];
            case /* Number */2 :
                return /* tuple */[
                        str,
                        /* Bool */1
                      ];
            
          }
        } else {
          return /* tuple */[
                  undefined,
                  /* CONFLICT */6
                ];
        }
    case /* GreaterThan */5 :
        var match$4 = Extraction_tool$Extraction.pass_check(op1[1], ope2[1]);
        if (typeof match$4 === "number" && match$4 < 3) {
          switch (match$4) {
            case /* HOLE */0 :
                return /* tuple */[
                        undefined,
                        /* HOLE */0
                      ];
            case /* Bool */1 :
                return /* tuple */[
                        undefined,
                        /* CONFLICT */6
                      ];
            case /* Number */2 :
                return /* tuple */[
                        str,
                        /* Bool */1
                      ];
            
          }
        } else {
          return /* tuple */[
                  undefined,
                  /* CONFLICT */6
                ];
        }
    case /* Equals */6 :
        var match$5 = Extraction_tool$Extraction.pass_check(op1[1], ope2[1]);
        if (typeof match$5 === "number" && match$5 < 3) {
          switch (match$5) {
            case /* HOLE */0 :
                return /* tuple */[
                        undefined,
                        /* HOLE */0
                      ];
            case /* Bool */1 :
                return /* tuple */[
                        undefined,
                        /* CONFLICT */6
                      ];
            case /* Number */2 :
                return /* tuple */[
                        str,
                        /* Bool */1
                      ];
            
          }
        } else {
          return /* tuple */[
                  undefined,
                  /* CONFLICT */6
                ];
        }
    case /* Comma */7 :
        var match$6 = op1[1];
        var match$7 = ope2[1];
        var exit = 0;
        var exit$1 = 0;
        var exit$2 = 0;
        if (typeof match$6 === "number" && match$6 === 0) {
          return /* tuple */[
                  undefined,
                  /* HOLE */0
                ];
        } else {
          exit$2 = 4;
        }
        if (exit$2 === 4) {
          if (typeof match$7 === "number") {
            if (match$7 !== 0) {
              if (match$7 >= 6) {
                return /* tuple */[
                        undefined,
                        /* CONFLICT */6
                      ];
              } else {
                exit$1 = 3;
              }
            } else {
              return /* tuple */[
                      undefined,
                      /* HOLE */0
                    ];
            }
          } else {
            exit$1 = 3;
          }
        }
        if (exit$1 === 3) {
          if (typeof match$6 === "number" && match$6 >= 4) {
            switch (match$6 - 4 | 0) {
              case /* HOLE */0 :
                  return /* tuple */[
                          "Variable not found",
                          /* CONFLICT */6
                        ];
              case /* Bool */1 :
                  exit = 2;
                  break;
              case /* Number */2 :
                  return /* tuple */[
                          undefined,
                          /* CONFLICT */6
                        ];
              
            }
          } else {
            exit = 2;
          }
        }
        if (exit === 2 && typeof match$7 === "number" && match$7 === 4) {
          return /* tuple */[
                  "Variable not found",
                  /* CONFLICT */6
                ];
        }
        return /* tuple */[
                str,
                /* PROD */Block.__(3, [
                    op1[1],
                    ope2[1]
                  ])
              ];
    case /* Cons */8 :
        var match$8 = op1[1];
        var match$9 = ope2[1];
        var exit$3 = 0;
        var exit$4 = 0;
        if (typeof match$8 === "number" && match$8 === 0) {
          return /* tuple */[
                  undefined,
                  /* HOLE */0
                ];
        } else {
          exit$4 = 3;
        }
        if (exit$4 === 3) {
          if (typeof match$9 === "number") {
            if (match$9 !== 0) {
              if (match$9 >= 6) {
                return /* tuple */[
                        undefined,
                        /* CONFLICT */6
                      ];
              } else {
                exit$3 = 2;
              }
            } else {
              return /* tuple */[
                      undefined,
                      /* HOLE */0
                    ];
            }
          } else {
            exit$3 = 2;
          }
        }
        if (exit$3 === 2 && typeof match$8 === "number" && match$8 >= 4) {
          switch (match$8 - 4 | 0) {
            case /* HOLE */0 :
                return /* tuple */[
                        "Variable not found",
                        /* CONFLICT */6
                      ];
            case /* Bool */1 :
                break;
            case /* Number */2 :
                return /* tuple */[
                        undefined,
                        /* CONFLICT */6
                      ];
            
          }
        }
        if (typeof match$9 === "number") {
          if (match$9 === /* EMPTY */4) {
            return /* tuple */[
                    "Variable not found",
                    /* CONFLICT */6
                  ];
          } else {
            return /* tuple */[
                    "Cons to not a List",
                    /* CONFLICT */6
                  ];
          }
        } else if (match$9.tag) {
          return /* tuple */[
                  "Cons to not a List",
                  /* CONFLICT */6
                ];
        } else {
          var b = match$9[0];
          if (typeof b === "number" && b === 5) {
            return /* tuple */[
                    str,
                    /* List */Block.__(0, [match$8])
                  ];
          } else {
            return /* tuple */[
                    str,
                    Extraction_tool$Extraction.pass_check(match$8, b)
                  ];
          }
        }
        break;
    case /* And */9 :
        var match$10 = Extraction_tool$Extraction.pass_check(op1[1], ope2[1]);
        if (typeof match$10 === "number") {
          if (match$10 !== 1) {
            if (match$10 !== 0) {
              return /* tuple */[
                      undefined,
                      /* CONFLICT */6
                    ];
            } else {
              return /* tuple */[
                      undefined,
                      /* HOLE */0
                    ];
            }
          } else {
            return /* tuple */[
                    str,
                    /* Bool */1
                  ];
          }
        } else {
          return /* tuple */[
                  undefined,
                  /* CONFLICT */6
                ];
        }
    case /* Or */10 :
        var match$11 = Extraction_tool$Extraction.pass_check(op1[1], ope2[1]);
        if (typeof match$11 === "number") {
          if (match$11 !== 1) {
            if (match$11 !== 0) {
              return /* tuple */[
                      undefined,
                      /* CONFLICT */6
                    ];
            } else {
              return /* tuple */[
                      undefined,
                      /* HOLE */0
                    ];
            }
          } else {
            return /* tuple */[
                    str,
                    /* Bool */1
                  ];
          }
        } else {
          return /* tuple */[
                  undefined,
                  /* CONFLICT */6
                ];
        }
    
  }
}

function extraction_call(t) {
  var match = uhexp_trans(t, /* [] */0);
  var match$1 = match[0];
  var match$2 = match[1];
  if (typeof match$2 === "number" && match$2 === 0) {
    return "Uncomplete holes exist";
  }
  if (match$1 !== undefined) {
    var match$3 = match[1];
    var s = match$1;
    if (typeof match$3 === "number" && match$3 >= 6) {
      return s + "Conflict Here";
    } else {
      return s;
    }
  } else {
    var match$4 = match[1];
    if (typeof match$4 === "number" && match$4 >= 6) {
      return "There's type unsupport in OCaml";
    } else {
      return "Something's wrong... ";
    }
  }
}

exports.uhexp_trans = uhexp_trans;
exports.line_trans = line_trans;
exports.uhexp_seq_trans = uhexp_seq_trans;
exports.uhexp_operand_trans = uhexp_operand_trans;
exports.lam_trans = lam_trans;
exports.inj_trans = inj_trans;
exports.case_trans = case_trans;
exports.rules_trans = rules_trans;
exports.rule_trans = rule_trans;
exports.uhexp_const = uhexp_const;
exports.extraction_call = extraction_call;
/* No side effect */

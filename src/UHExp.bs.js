// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';

var List = require("bs-platform/lib/js/list.js");
var Block = require("bs-platform/lib/js/block.js");
var Pervasives = require("bs-platform/lib/js/pervasives.js");
var OpSeq$Extraction = require("./OpSeq.bs.js");
var UHPat$Extraction = require("./UHPat.bs.js");
var OptUtil$Extraction = require("./OptUtil.bs.js");
var ListUtil$Extraction = require("./ListUtil.bs.js");
var MetaVarGen$Extraction = require("./MetaVarGen.bs.js");

function string_of_operator(param) {
  switch (param) {
    case /* Space */0 :
        return " ";
    case /* Plus */1 :
        return "+";
    case /* Minus */2 :
        return "-";
    case /* Times */3 :
        return "*";
    case /* LessThan */4 :
        return "<";
    case /* GreaterThan */5 :
        return ">";
    case /* Equals */6 :
        return "==";
    case /* Comma */7 :
        return ",";
    case /* Cons */8 :
        return "::";
    case /* And */9 :
        return "&&";
    case /* Or */10 :
        return "||";
    
  }
}

function is_Space(param) {
  return param === 0;
}

function is_Comma(param) {
  return param === 7;
}

function letline(p, ann, def) {
  return /* LetLine */Block.__(0, [
            p,
            ann,
            def
          ]);
}

function $$var($staropt$star, $staropt$star$1, x) {
  var err = $staropt$star !== undefined ? $staropt$star : /* NotInHole */0;
  var var_err = $staropt$star$1 !== undefined ? $staropt$star$1 : /* NotInVarHole */0;
  return /* Var */Block.__(1, [
            err,
            var_err,
            x
          ]);
}

function numlit($staropt$star, n) {
  var err = $staropt$star !== undefined ? $staropt$star : /* NotInHole */0;
  return /* NumLit */Block.__(2, [
            err,
            n
          ]);
}

function boollit($staropt$star, b) {
  var err = $staropt$star !== undefined ? $staropt$star : /* NotInHole */0;
  return /* BoolLit */Block.__(3, [
            err,
            b
          ]);
}

function lam($staropt$star, p, ann, body) {
  var err = $staropt$star !== undefined ? $staropt$star : /* NotInHole */0;
  return /* Lam */Block.__(5, [
            err,
            p,
            ann,
            body
          ]);
}

function $$case($staropt$star, ann, scrut, rules) {
  var err = $staropt$star !== undefined ? $staropt$star : /* NotInHole */0;
  return /* Case */Block.__(7, [
            err,
            scrut,
            rules,
            ann
          ]);
}

function listnil($staropt$star, param) {
  var err = $staropt$star !== undefined ? $staropt$star : /* NotInHole */0;
  return /* ListNil */Block.__(4, [err]);
}

function prune_empty_hole(line) {
  if (typeof line === "number" || !line.tag) {
    return line;
  } else {
    var match = line[0][1];
    if (match[0].tag || match[1]) {
      return line;
    } else {
      return /* EmptyLine */0;
    }
  }
}

function get_opseq(param) {
  if (typeof param === "number" || !param.tag) {
    return ;
  } else {
    return param[0];
  }
}

function force_get_opseq(line) {
  return OptUtil$Extraction.get((function (param) {
                return Pervasives.failwith("force_get_opseq: expected ExpLine");
              }), get_opseq(line));
}

var Line = {
  prune_empty_hole: prune_empty_hole,
  get_opseq: get_opseq,
  force_get_opseq: force_get_opseq
};

function prune_empty_holes(lines) {
  return List.map(prune_empty_hole, lines);
}

var Lines = {
  prune_empty_holes: prune_empty_holes
};

function wrap$prime(opseq) {
  return /* :: */[
          /* ExpLine */Block.__(1, [opseq]),
          /* [] */0
        ];
}

function wrap(operand) {
  var opseq = OpSeq$Extraction.wrap(operand);
  return /* :: */[
          /* ExpLine */Block.__(1, [opseq]),
          /* [] */0
        ];
}

function prune_empty_hole_lines(block) {
  var match = ListUtil$Extraction.split_last(block);
  if (match !== undefined) {
    var match$1 = match;
    return Pervasives.$at(List.map(prune_empty_hole, match$1[0]), /* :: */[
                match$1[1],
                /* [] */0
              ]);
  } else {
    return block;
  }
}

function split_conclusion(block) {
  var match = ListUtil$Extraction.split_last(block);
  if (match !== undefined) {
    var match$1 = match;
    var match$2 = get_opseq(match$1[1]);
    if (match$2 !== undefined) {
      return /* tuple */[
              match$1[0],
              match$2
            ];
    } else {
      return ;
    }
  }
  
}

function force_split_conclusion(block) {
  var match = split_conclusion(block);
  if (match !== undefined) {
    var match$1 = match;
    return /* tuple */[
            match$1[0],
            match$1[1]
          ];
  } else {
    return Pervasives.failwith("force_split_conclusion: unconcluded block");
  }
}

function join_conclusion(leading, conclusion) {
  return Pervasives.$at(leading, /* :: */[
              /* ExpLine */Block.__(1, [conclusion]),
              /* [] */0
            ]);
}

var Block$1 = {
  wrap$prime: wrap$prime,
  wrap: wrap,
  num_lines: List.length,
  prune_empty_hole_lines: prune_empty_hole_lines,
  split_conclusion: split_conclusion,
  force_split_conclusion: force_split_conclusion,
  join_conclusion: join_conclusion
};

function get_tuple_elements(skel) {
  if (skel.tag && skel[1] === 7) {
    return Pervasives.$at(get_tuple_elements(skel[2]), get_tuple_elements(skel[3]));
  } else {
    return /* :: */[
            skel,
            /* [] */0
          ];
  }
}

function make_tuple(err, elements) {
  if (elements) {
    var skels = elements[1];
    var skel = elements[0];
    if (skels) {
      return /* BinOp */Block.__(1, [
                err,
                /* Comma */7,
                skel,
                make_tuple(/* NotInHole */0, skels)
              ]);
    } else {
      return skel;
    }
  } else {
    return Pervasives.failwith("make_tuple: expected at least 1 element");
  }
}

function new_EmptyHole(u_gen) {
  var match = MetaVarGen$Extraction.next(u_gen);
  return /* tuple */[
          /* EmptyHole */Block.__(0, [match[0]]),
          match[1]
        ];
}

function is_EmptyHole(param) {
  if (param.tag) {
    return false;
  } else {
    return true;
  }
}

function empty_rule(u_gen) {
  var match = UHPat$Extraction.new_EmptyHole(u_gen);
  var match$1 = new_EmptyHole(match[1]);
  var rule_000 = OpSeq$Extraction.wrap(match[0]);
  var rule_001 = wrap(match$1[0]);
  var rule = /* Rule */[
    rule_000,
    rule_001
  ];
  return /* tuple */[
          rule,
          match$1[1]
        ];
}

function get_err_status_block(block) {
  var match = force_split_conclusion(block);
  return OpSeq$Extraction.get_err_status(get_err_status_operand, match[1]);
}

function get_err_status_operand(param) {
  switch (param.tag | 0) {
    case /* EmptyHole */0 :
        return /* NotInHole */0;
    case /* Parenthesized */8 :
        return get_err_status_block(param[0]);
    default:
      return param[0];
  }
}

var get_err_status = get_err_status_block;

function get_err_status_opseq(opseq) {
  return OpSeq$Extraction.get_err_status(get_err_status_operand, opseq);
}

function set_err_status_block(err, block) {
  var match = force_split_conclusion(block);
  return join_conclusion(match[0], OpSeq$Extraction.set_err_status(set_err_status_operand, err, match[1]));
}

function set_err_status_operand(err, operand) {
  switch (operand.tag | 0) {
    case /* EmptyHole */0 :
        return operand;
    case /* Var */1 :
        return /* Var */Block.__(1, [
                  err,
                  operand[1],
                  operand[2]
                ]);
    case /* NumLit */2 :
        return /* NumLit */Block.__(2, [
                  err,
                  operand[1]
                ]);
    case /* BoolLit */3 :
        return /* BoolLit */Block.__(3, [
                  err,
                  operand[1]
                ]);
    case /* ListNil */4 :
        return /* ListNil */Block.__(4, [err]);
    case /* Lam */5 :
        return /* Lam */Block.__(5, [
                  err,
                  operand[1],
                  operand[2],
                  operand[3]
                ]);
    case /* Inj */6 :
        return /* Inj */Block.__(6, [
                  err,
                  operand[1],
                  operand[2]
                ]);
    case /* Case */7 :
        return /* Case */Block.__(7, [
                  err,
                  operand[1],
                  operand[2],
                  operand[3]
                ]);
    case /* Parenthesized */8 :
        return /* Parenthesized */Block.__(8, [set_err_status_block(err, operand[0])]);
    case /* ApPalette */9 :
        return /* ApPalette */Block.__(9, [
                  err,
                  operand[1],
                  operand[2],
                  operand[3]
                ]);
    
  }
}

var set_err_status = set_err_status_block;

function set_err_status_opseq(err, opseq) {
  return OpSeq$Extraction.set_err_status(set_err_status_operand, err, opseq);
}

function is_inconsistent(operand) {
  var match = get_err_status_operand(operand);
  if (match && !match[0]) {
    return true;
  } else {
    return false;
  }
}

function make_inconsistent_block(u_gen, block) {
  var match = force_split_conclusion(block);
  var match$1 = OpSeq$Extraction.make_inconsistent(make_inconsistent_operand, u_gen, match[1]);
  return /* tuple */[
          join_conclusion(match[0], match$1[0]),
          match$1[1]
        ];
}

function make_inconsistent_operand(u_gen, operand) {
  switch (operand.tag | 0) {
    case /* EmptyHole */0 :
        return /* tuple */[
                operand,
                u_gen
              ];
    case /* Var */1 :
        var match = operand[0];
        if (match && !match[0]) {
          return /* tuple */[
                  operand,
                  u_gen
                ];
        }
        break;
    case /* NumLit */2 :
        var match$1 = operand[0];
        if (match$1 && !match$1[0]) {
          return /* tuple */[
                  operand,
                  u_gen
                ];
        }
        break;
    case /* BoolLit */3 :
        var match$2 = operand[0];
        if (match$2 && !match$2[0]) {
          return /* tuple */[
                  operand,
                  u_gen
                ];
        }
        break;
    case /* ListNil */4 :
        var match$3 = operand[0];
        if (match$3 && !match$3[0]) {
          return /* tuple */[
                  operand,
                  u_gen
                ];
        }
        break;
    case /* Lam */5 :
        var match$4 = operand[0];
        if (match$4 && !match$4[0]) {
          return /* tuple */[
                  operand,
                  u_gen
                ];
        }
        break;
    case /* Inj */6 :
        var match$5 = operand[0];
        if (match$5 && !match$5[0]) {
          return /* tuple */[
                  operand,
                  u_gen
                ];
        }
        break;
    case /* Case */7 :
        var match$6 = operand[0];
        if (match$6 && !match$6[0]) {
          return /* tuple */[
                  operand,
                  u_gen
                ];
        }
        break;
    case /* Parenthesized */8 :
        var match$7 = make_inconsistent_block(u_gen, operand[0]);
        return /* tuple */[
                /* Parenthesized */Block.__(8, [match$7[0]]),
                match$7[1]
              ];
    case /* ApPalette */9 :
        var match$8 = operand[0];
        if (match$8 && !match$8[0]) {
          return /* tuple */[
                  operand,
                  u_gen
                ];
        }
        break;
    
  }
  var match$9 = MetaVarGen$Extraction.next(u_gen);
  var operand$1 = set_err_status_operand(/* InHole */[
        /* TypeInconsistent */0,
        match$9[0]
      ], operand);
  return /* tuple */[
          operand$1,
          match$9[1]
        ];
}

var make_inconsistent = make_inconsistent_block;

function make_inconsistent_opseq(u_gen, opseq) {
  return OpSeq$Extraction.make_inconsistent(make_inconsistent_operand, u_gen, opseq);
}

function drop_outer_parentheses(_operand) {
  while(true) {
    var operand = _operand;
    if (operand.tag === /* Parenthesized */8) {
      var e = operand[0];
      if (e) {
        var match = e[0];
        if (typeof match === "number" || !match.tag) {
          return e;
        } else {
          var match$1 = match[0][1];
          if (match$1[1] || e[1]) {
            return e;
          } else {
            _operand = match$1[0];
            continue ;
          }
        }
      } else {
        return e;
      }
    } else {
      return wrap(operand);
    }
  };
}

exports.string_of_operator = string_of_operator;
exports.is_Space = is_Space;
exports.is_Comma = is_Comma;
exports.letline = letline;
exports.$$var = $$var;
exports.numlit = numlit;
exports.boollit = boollit;
exports.lam = lam;
exports.$$case = $$case;
exports.listnil = listnil;
exports.Line = Line;
exports.Lines = Lines;
exports.Block = Block$1;
exports.get_tuple_elements = get_tuple_elements;
exports.make_tuple = make_tuple;
exports.new_EmptyHole = new_EmptyHole;
exports.is_EmptyHole = is_EmptyHole;
exports.empty_rule = empty_rule;
exports.get_err_status = get_err_status;
exports.get_err_status_block = get_err_status_block;
exports.get_err_status_opseq = get_err_status_opseq;
exports.get_err_status_operand = get_err_status_operand;
exports.set_err_status = set_err_status;
exports.set_err_status_block = set_err_status_block;
exports.set_err_status_opseq = set_err_status_opseq;
exports.set_err_status_operand = set_err_status_operand;
exports.is_inconsistent = is_inconsistent;
exports.make_inconsistent = make_inconsistent;
exports.make_inconsistent_block = make_inconsistent_block;
exports.make_inconsistent_opseq = make_inconsistent_opseq;
exports.make_inconsistent_operand = make_inconsistent_operand;
exports.drop_outer_parentheses = drop_outer_parentheses;
/* No side effect */

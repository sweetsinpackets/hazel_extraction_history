// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';

var List = require("bs-platform/lib/js/list.js");
var Curry = require("bs-platform/lib/js/curry.js");
var Caml_obj = require("bs-platform/lib/js/caml_obj.js");
var Caml_option = require("bs-platform/lib/js/caml_option.js");

function extend_unique(delta, x) {
  return /* :: */[
          x,
          delta
        ];
}

function drop(_delta, n) {
  while(true) {
    var delta = _delta;
    if (delta) {
      var delta$prime = delta[1];
      var match = delta[0];
      if (n === match[0]) {
        return /* tuple */[
                delta$prime,
                match[1]
              ];
      } else {
        _delta = delta$prime;
        continue ;
      }
    } else {
      return ;
    }
  };
}

function lookup(_delta, x) {
  while(true) {
    var delta = _delta;
    if (delta) {
      var match = delta[0];
      if (Caml_obj.caml_equal(x, match[0])) {
        return Caml_option.some(match[1]);
      } else {
        _delta = delta[1];
        continue ;
      }
    } else {
      return ;
    }
  };
}

function insert_or_update(delta, x) {
  if (delta) {
    var delta$prime = delta[1];
    var match = delta[0];
    var u$prime = match[0];
    if (Caml_obj.caml_equal(x[0], u$prime)) {
      return /* :: */[
              /* tuple */[
                u$prime,
                x[1]
              ],
              delta$prime
            ];
    } else {
      return /* :: */[
              /* tuple */[
                u$prime,
                match[1]
              ],
              insert_or_update(delta$prime, x)
            ];
    }
  } else {
    return /* :: */[
            x,
            delta
          ];
  }
}

function insert_or_map(delta, u, a0, f) {
  if (delta) {
    var delta$prime = delta[1];
    var match = delta[0];
    var a = match[1];
    var u$prime = match[0];
    if (u === u$prime) {
      var a$prime = Curry._1(f, a);
      return /* tuple */[
              a$prime,
              /* :: */[
                /* tuple */[
                  u$prime,
                  a$prime
                ],
                delta$prime
              ]
            ];
    } else {
      var match$1 = insert_or_map(delta$prime, u, a0, f);
      return /* tuple */[
              match$1[0],
              /* :: */[
                /* tuple */[
                  u$prime,
                  a
                ],
                match$1[1]
              ]
            ];
    }
  } else {
    var a0$1 = Curry._1(a0, /* () */0);
    return /* tuple */[
            a0$1,
            /* :: */[
              /* tuple */[
                u,
                a0$1
              ],
              delta
            ]
          ];
  }
}

function map(f, param) {
  if (param) {
    var match = param[0];
    return /* :: */[
            /* tuple */[
              match[0],
              Curry._1(f, match[1])
            ],
            map(f, param[1])
          ];
  } else {
    return /* [] */0;
  }
}

function update_with(f, u, delta, u_nil) {
  if (delta) {
    var delta$prime = delta[1];
    var match = delta[0];
    var a = match[1];
    var u$prime = match[0];
    if (Caml_obj.caml_equal(u, u$prime)) {
      var a$prime = Curry._1(f, a);
      return /* tuple */[
              a$prime,
              /* :: */[
                /* tuple */[
                  u$prime,
                  a$prime
                ],
                delta$prime
              ]
            ];
    } else {
      var match$1 = update_with(f, u, delta$prime, u_nil);
      return /* tuple */[
              match$1[0],
              /* :: */[
                /* tuple */[
                  u$prime,
                  a
                ],
                match$1[1]
              ]
            ];
    }
  } else {
    return /* tuple */[
            u_nil,
            delta
          ];
  }
}

function to_list(delta) {
  return delta;
}

function fold(delta, f, b) {
  return List.fold_left(f, b, delta);
}

var NatMap = {
  empty: /* [] */0,
  extend_unique: extend_unique,
  drop: drop,
  union: List.append,
  lookup: lookup,
  insert_or_update: insert_or_update,
  insert_or_map: insert_or_map,
  map: map,
  update_with: update_with,
  length: List.length,
  to_list: to_list,
  fold: fold
};

exports.NatMap = NatMap;
/* No side effect */

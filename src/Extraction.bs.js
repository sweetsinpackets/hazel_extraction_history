// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';

var Block = require("bs-platform/lib/js/block.js");
var Pervasives = require("bs-platform/lib/js/pervasives.js");

function indent_space(level) {
  if (level > 0) {
    return "  " + indent_space(level - 1 | 0);
  } else {
    return "";
  }
}

function option_string_concat(strs) {
  if (strs) {
    var a = strs[0];
    var match = option_string_concat(strs[1]);
    if (a !== undefined && match !== undefined) {
      return a + match;
    } else {
      return ;
    }
  } else {
    return "";
  }
}

function uhtyp_translater(t) {
  if (typeof t === "number") {
    switch (t) {
      case /* Hole */0 :
          return ;
      case /* Unit */1 :
          return "()";
      case /* Num */2 :
          return "int";
      case /* Bool */3 :
          return "bool";
      
    }
  } else {
    switch (t.tag | 0) {
      case /* Parenthesized */0 :
          return option_string_concat(/* :: */[
                      "(",
                      /* :: */[
                        uhtyp_translater(t[0]),
                        /* :: */[
                          ")",
                          /* [] */0
                        ]
                      ]
                    ]);
      case /* List */1 :
          return option_string_concat(/* :: */[
                      uhtyp_translater(t[0]),
                      /* :: */[
                        " list",
                        /* [] */0
                      ]
                    ]);
      case /* OpSeq */2 :
          var skel_t = t[0];
          if (skel_t.tag && !skel_t[0]) {
            return uhtyp_opseq_translater(t[1]);
          } else {
            return ;
          }
      
    }
  }
}

function uhtyp_opseq_translater(opseq) {
  if (opseq.tag) {
    return option_string_concat(/* :: */[
                uhtyp_opseq_translater(opseq[0]),
                /* :: */[
                  uhtyp_op_translater(opseq[1]),
                  /* :: */[
                    uhtyp_translater(opseq[2]),
                    /* [] */0
                  ]
                ]
              ]);
  } else {
    return option_string_concat(/* :: */[
                uhtyp_translater(opseq[0]),
                /* :: */[
                  uhtyp_op_translater(opseq[1]),
                  /* :: */[
                    uhtyp_translater(opseq[2]),
                    /* [] */0
                  ]
                ]
              ]);
  }
}

function uhtyp_op_translater(op) {
  switch (op) {
    case /* Arrow */0 :
        return " -> ";
    case /* Prod */1 :
        return " * ";
    case /* Sum */2 :
        return " | ";
    
  }
}

function uhpat_translater(_t) {
  while(true) {
    var t = _t;
    switch (t.tag | 0) {
      case /* EmptyHole */0 :
          return ;
      case /* Wild */1 :
          if (t[0]) {
            return ;
          } else {
            return "_";
          }
      case /* Var */2 :
          if (t[0] || t[1]) {
            return ;
          } else {
            return t[2];
          }
      case /* NumLit */3 :
          if (t[0]) {
            return ;
          } else {
            return String(t[1]);
          }
      case /* BoolLit */4 :
          if (t[0]) {
            return ;
          } else {
            return Pervasives.string_of_bool(t[1]);
          }
      case /* ListNil */5 :
          if (t[0]) {
            return ;
          } else {
            return "[]";
          }
      case /* Parenthesized */6 :
          var match = uhpat_translater(t[0]);
          if (match !== undefined) {
            return "(" + (match + ")");
          } else {
            return ;
          }
      case /* OpSeq */7 :
          var skel_t = t[0];
          if (skel_t.tag && !skel_t[0]) {
            return uhpat_opseq_translater(t[1]);
          } else {
            return ;
          }
      case /* Inj */8 :
          if (t[0]) {
            return ;
          } else {
            _t = t[2];
            continue ;
          }
      
    }
  };
}

function uhpat_opseq_translater(opseq) {
  if (opseq.tag) {
    return option_string_concat(/* :: */[
                uhpat_opseq_translater(opseq[0]),
                /* :: */[
                  uhpat_op_translater(opseq[1]),
                  /* :: */[
                    uhpat_translater(opseq[2]),
                    /* [] */0
                  ]
                ]
              ]);
  } else {
    return option_string_concat(/* :: */[
                uhpat_translater(opseq[0]),
                /* :: */[
                  uhpat_op_translater(opseq[1]),
                  /* :: */[
                    uhpat_translater(opseq[2]),
                    /* [] */0
                  ]
                ]
              ]);
  }
}

function uhpat_op_translater(op) {
  switch (op) {
    case /* Comma */0 :
        return ", ";
    case /* Space */1 :
        return " ";
    case /* Cons */2 :
        return " :: ";
    
  }
}

function uhexp_op_translater(op) {
  switch (op) {
    case /* Space */0 :
        return " ";
    case /* Plus */1 :
        return "+";
    case /* Minus */2 :
        return "-";
    case /* Times */3 :
        return "*";
    case /* LessThan */4 :
        return "<";
    case /* GreaterThan */5 :
        return ">";
    case /* Equals */6 :
        return "==";
    case /* Comma */7 :
        return ", ";
    case /* Cons */8 :
        return "::";
    case /* And */9 :
        return "&&";
    case /* Or */10 :
        return "||";
    
  }
}

function block_handler(block, level) {
  return option_string_concat(/* :: */[
              lines_handler(block[0], level),
              /* :: */[
                type_handler(block[1], level),
                /* [] */0
              ]
            ]);
}

function type_handler(t, level) {
  switch (t.tag | 0) {
    case /* Var */1 :
        if (t[0] || t[1]) {
          return ;
        } else {
          return t[2];
        }
    case /* NumLit */2 :
        if (t[0]) {
          return ;
        } else {
          return String(t[1]);
        }
    case /* BoolLit */3 :
        if (t[0]) {
          return ;
        } else {
          return Pervasives.string_of_bool(t[1]);
        }
    case /* ListNil */4 :
        if (t[0]) {
          return ;
        } else {
          return "[]";
        }
    case /* Lam */5 :
        return lam_handler(t[0], t[1], t[2], t[3], level);
    case /* Inj */6 :
        return inj_handler(t[0], t[2], level);
    case /* Case */7 :
        if (t[0]) {
          return ;
        } else {
          return case_handler(t[1], t[2], t[3], level);
        }
    case /* Parenthesized */8 :
        return option_string_concat(/* :: */[
                    "(",
                    /* :: */[
                      block_handler(t[0], level),
                      /* :: */[
                        ")",
                        /* [] */0
                      ]
                    ]
                  ]);
    case /* OpSeq */9 :
        var skel_t = t[0];
        if (skel_t.tag && !skel_t[0]) {
          return opseq_handler(t[1], level);
        } else {
          return ;
        }
    case /* EmptyHole */0 :
    case /* ApPalette */10 :
        return ;
    
  }
}

function lam_handler(errstatus, uhpat, uhtyp, block, level) {
  if (errstatus) {
    return ;
  } else if (uhtyp !== undefined) {
    return option_string_concat(/* :: */[
                "(fun ",
                /* :: */[
                  uhpat_translater(uhpat),
                  /* :: */[
                    " : ",
                    /* :: */[
                      uhtyp_translater(uhtyp),
                      /* :: */[
                        " -> ",
                        /* :: */[
                          block_handler(block, level + 1 | 0),
                          /* :: */[
                            ")",
                            /* [] */0
                          ]
                        ]
                      ]
                    ]
                  ]
                ]
              ]);
  } else {
    return option_string_concat(/* :: */[
                "(fun ",
                /* :: */[
                  uhpat_translater(uhpat),
                  /* :: */[
                    " -> ",
                    /* :: */[
                      block_handler(block, level + 1 | 0),
                      /* :: */[
                        ")",
                        /* [] */0
                      ]
                    ]
                  ]
                ]
              ]);
  }
}

function inj_handler(errstatus, block, level) {
  if (errstatus) {
    return ;
  } else {
    return block_handler(block, level + 1 | 0);
  }
}

function opseq_handler(opseq, level) {
  if (opseq.tag) {
    return option_string_concat(/* :: */[
                opseq_handler(opseq[0], level + 1 | 0),
                /* :: */[
                  uhexp_op_translater(opseq[1]),
                  /* :: */[
                    type_handler(opseq[2], level + 1 | 0),
                    /* [] */0
                  ]
                ]
              ]);
  } else {
    return option_string_concat(/* :: */[
                type_handler(opseq[0], level + 1 | 0),
                /* :: */[
                  uhexp_op_translater(opseq[1]),
                  /* :: */[
                    type_handler(opseq[2], level + 1 | 0),
                    /* [] */0
                  ]
                ]
              ]);
  }
}

function case_handler(block, rules, uhtyp, level) {
  if (uhtyp !== undefined) {
    return option_string_concat(/* :: */[
                "((match ",
                /* :: */[
                  block_handler(block, level),
                  /* :: */[
                    " with",
                    /* :: */[
                      rule_handler(rules, level + 1 | 0),
                      /* :: */[
                        ") : ",
                        /* :: */[
                          uhtyp_translater(uhtyp),
                          /* :: */[
                            ")",
                            /* [] */0
                          ]
                        ]
                      ]
                    ]
                  ]
                ]
              ]);
  } else {
    return option_string_concat(/* :: */[
                "(match ",
                /* :: */[
                  block_handler(block, level),
                  /* :: */[
                    " with",
                    /* :: */[
                      rule_handler(rules, level + 1 | 0),
                      /* :: */[
                        ")",
                        /* [] */0
                      ]
                    ]
                  ]
                ]
              ]);
  }
}

function rule_handler(rules, level) {
  if (rules) {
    var rule = rules[0];
    return option_string_concat(/* :: */[
                "\n",
                /* :: */[
                  indent_space(level),
                  /* :: */[
                    "| ",
                    /* :: */[
                      uhpat_translater(rule[0]),
                      /* :: */[
                        " -> ",
                        /* :: */[
                          block_handler(rule[1], level + 1 | 0),
                          /* :: */[
                            rule_handler(rules[1], level),
                            /* [] */0
                          ]
                        ]
                      ]
                    ]
                  ]
                ]
              ]);
  } else {
    return "";
  }
}

function lines_handler(lines, level) {
  if (lines) {
    return option_string_concat(/* :: */[
                line_handler(lines[0], level),
                /* :: */[
                  lines_handler(lines[1], level),
                  /* [] */0
                ]
              ]);
  } else {
    return "";
  }
}

function line_handler(line, level) {
  if (typeof line === "number") {
    return "\n";
  } else if (line.tag) {
    var block = line[2];
    var uhtyp = line[1];
    var uhpat = line[0];
    if (uhtyp !== undefined) {
      return option_string_concat(/* :: */[
                  "let ",
                  /* :: */[
                    uhpat_translater(uhpat),
                    /* :: */[
                      " : ",
                      /* :: */[
                        uhtyp_translater(uhtyp),
                        /* :: */[
                          " = ",
                          /* :: */[
                            block_handler(block, level + 1 | 0),
                            /* :: */[
                              " in\n",
                              /* :: */[
                                indent_space(level),
                                /* [] */0
                              ]
                            ]
                          ]
                        ]
                      ]
                    ]
                  ]
                ]);
    } else {
      return option_string_concat(/* :: */[
                  "let ",
                  /* :: */[
                    uhpat_translater(uhpat),
                    /* :: */[
                      " = ",
                      /* :: */[
                        block_handler(block, level + 1 | 0),
                        /* :: */[
                          " in\n",
                          /* :: */[
                            indent_space(level),
                            /* [] */0
                          ]
                        ]
                      ]
                    ]
                  ]
                ]);
    }
  } else {
    return option_string_concat(/* :: */[
                type_handler(line[0], level),
                /* :: */[
                  "\n",
                  /* :: */[
                    indent_space(level),
                    /* [] */0
                  ]
                ]
              ]);
  }
}

function extraction_call(block) {
  var match = block_handler(block, 0);
  if (match !== undefined) {
    return match + ";;";
  } else {
    return "There could be some error in the code. Most possible is incomplete holes.";
  }
}

var case_example2 = /* Block */[
  /* [] */0,
  /* Case */Block.__(7, [
      /* NotInHole */0,
      /* Block */[
        /* [] */0,
        /* Var */Block.__(1, [
            /* NotInHole */0,
            /* NotInVarHole */0,
            "x"
          ])
      ],
      /* :: */[
        /* Rule */[
          /* ListNil */Block.__(5, [/* NotInHole */0]),
          /* Block */[
            /* [] */0,
            /* Lam */Block.__(5, [
                /* NotInHole */0,
                /* Var */Block.__(2, [
                    /* NotInHole */0,
                    /* NotInVarHole */0,
                    "x"
                  ]),
                /* Num */2,
                /* Block */[
                  /* [] */0,
                  /* Lam */Block.__(5, [
                      /* NotInHole */0,
                      /* Var */Block.__(2, [
                          /* NotInHole */0,
                          /* NotInVarHole */0,
                          "y"
                        ]),
                      /* Num */2,
                      /* Block */[
                        /* [] */0,
                        /* Var */Block.__(1, [
                            /* NotInHole */0,
                            /* NotInVarHole */0,
                            "xy"
                          ])
                      ]
                    ])
                ]
              ])
          ]
        ],
        /* :: */[
          /* Rule */[
            /* Var */Block.__(2, [
                /* NotInHole */0,
                /* NotInVarHole */0,
                "a"
              ]),
            /* Block */[
              /* [] */0,
              /* BoolLit */Block.__(3, [
                  /* NotInHole */0,
                  true
                ])
            ]
          ],
          /* :: */[
            /* Rule */[
              /* Wild */Block.__(1, [/* NotInHole */0]),
              /* Block */[
                /* [] */0,
                /* Case */Block.__(7, [
                    /* NotInHole */0,
                    /* Block */[
                      /* [] */0,
                      /* Var */Block.__(1, [
                          /* NotInHole */0,
                          /* NotInVarHole */0,
                          "y"
                        ])
                    ],
                    /* :: */[
                      /* Rule */[
                        /* ListNil */Block.__(5, [/* NotInHole */0]),
                        /* Block */[
                          /* [] */0,
                          /* NumLit */Block.__(2, [
                              /* NotInHole */0,
                              1
                            ])
                        ]
                      ],
                      /* :: */[
                        /* Rule */[
                          /* Var */Block.__(2, [
                              /* NotInHole */0,
                              /* NotInVarHole */0,
                              "b"
                            ]),
                          /* Block */[
                            /* [] */0,
                            /* BoolLit */Block.__(3, [
                                /* NotInHole */0,
                                true
                              ])
                          ]
                        ],
                        /* [] */0
                      ]
                    ],
                    /* Unit */1
                  ])
              ]
            ],
            /* :: */[
              /* Rule */[
                /* Var */Block.__(2, [
                    /* NotInHole */0,
                    /* NotInVarHole */0,
                    "a"
                  ]),
                /* Block */[
                  /* [] */0,
                  /* BoolLit */Block.__(3, [
                      /* NotInHole */0,
                      true
                    ])
                ]
              ],
              /* [] */0
            ]
          ]
        ]
      ],
      /* Unit */1
    ])
];

var parenthesized_example1_001 = /* Parenthesized */Block.__(8, [case_example2]);

var parenthesized_example1 = /* Block */[
  /* [] */0,
  parenthesized_example1_001
];

console.log(extraction_call(parenthesized_example1));

var example_let = /* Block */[
  /* :: */[
    /* LetLine */Block.__(1, [
        /* Var */Block.__(2, [
            /* NotInHole */0,
            /* NotInVarHole */0,
            "x"
          ]),
        undefined,
        /* Block */[
          /* [] */0,
          /* NumLit */Block.__(2, [
              /* NotInHole */0,
              3
            ])
        ]
      ]),
    /* [] */0
  ],
  /* Var */Block.__(1, [
      /* NotInHole */0,
      /* NotInVarHole */0,
      "x"
    ])
];

var example_123 = /* Block */[
  /* [] */0,
  /* NumLit */Block.__(2, [
      /* NotInHole */0,
      123
    ])
];

var example_true = /* Block */[
  /* [] */0,
  /* BoolLit */Block.__(3, [
      /* NotInHole */0,
      true
    ])
];

var example_emptyhole = /* Block */[
  /* [] */0,
  /* EmptyHole */Block.__(0, [45])
];

var example_listnil = /* Block */[
  /* [] */0,
  /* ListNil */Block.__(4, [/* NotInHole */0])
];

var example_lam1 = /* Block */[
  /* [] */0,
  /* Lam */Block.__(5, [
      /* NotInHole */0,
      /* Var */Block.__(2, [
          /* NotInHole */0,
          /* NotInVarHole */0,
          "x"
        ]),
      undefined,
      /* Block */[
        /* [] */0,
        /* Var */Block.__(1, [
            /* NotInHole */0,
            /* NotInVarHole */0,
            "x"
          ])
      ]
    ])
];

var example_lam2 = /* Block */[
  /* [] */0,
  /* Lam */Block.__(5, [
      /* NotInHole */0,
      /* Var */Block.__(2, [
          /* NotInHole */0,
          /* NotInVarHole */0,
          "x"
        ]),
      /* Num */2,
      /* Block */[
        /* [] */0,
        /* Lam */Block.__(5, [
            /* NotInHole */0,
            /* Var */Block.__(2, [
                /* NotInHole */0,
                /* NotInVarHole */0,
                "y"
              ]),
            /* Num */2,
            /* Block */[
              /* [] */0,
              /* Var */Block.__(1, [
                  /* NotInHole */0,
                  /* NotInVarHole */0,
                  "xy"
                ])
            ]
          ])
      ]
    ])
];

var case_example1 = /* Block */[
  /* [] */0,
  /* Case */Block.__(7, [
      /* NotInHole */0,
      /* Block */[
        /* [] */0,
        /* Var */Block.__(1, [
            /* NotInHole */0,
            /* NotInVarHole */0,
            "x"
          ])
      ],
      /* :: */[
        /* Rule */[
          /* ListNil */Block.__(5, [/* NotInHole */0]),
          /* Block */[
            /* [] */0,
            /* NumLit */Block.__(2, [
                /* NotInHole */0,
                0
              ])
          ]
        ],
        /* :: */[
          /* Rule */[
            /* Var */Block.__(2, [
                /* NotInHole */0,
                /* NotInVarHole */0,
                "a"
              ]),
            /* Block */[
              /* [] */0,
              /* BoolLit */Block.__(3, [
                  /* NotInHole */0,
                  true
                ])
            ]
          ],
          /* [] */0
        ]
      ],
      /* Unit */1
    ])
];

exports.indent_space = indent_space;
exports.option_string_concat = option_string_concat;
exports.uhtyp_translater = uhtyp_translater;
exports.uhtyp_opseq_translater = uhtyp_opseq_translater;
exports.uhtyp_op_translater = uhtyp_op_translater;
exports.uhpat_translater = uhpat_translater;
exports.uhpat_opseq_translater = uhpat_opseq_translater;
exports.uhpat_op_translater = uhpat_op_translater;
exports.uhexp_op_translater = uhexp_op_translater;
exports.block_handler = block_handler;
exports.type_handler = type_handler;
exports.lam_handler = lam_handler;
exports.inj_handler = inj_handler;
exports.opseq_handler = opseq_handler;
exports.case_handler = case_handler;
exports.rule_handler = rule_handler;
exports.lines_handler = lines_handler;
exports.line_handler = line_handler;
exports.extraction_call = extraction_call;
exports.example_let = example_let;
exports.example_123 = example_123;
exports.example_true = example_true;
exports.example_emptyhole = example_emptyhole;
exports.example_listnil = example_listnil;
exports.example_lam1 = example_lam1;
exports.example_lam2 = example_lam2;
exports.case_example1 = case_example1;
exports.case_example2 = case_example2;
exports.parenthesized_example1 = parenthesized_example1;
/*  Not a pure module */

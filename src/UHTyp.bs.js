// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';

var Block = require("bs-platform/lib/js/block.js");
var Pervasives = require("bs-platform/lib/js/pervasives.js");
var Seq$Extraction = require("./Seq.bs.js");
var OpSeq$Extraction = require("./OpSeq.bs.js");
var UnicodeConstants$Extraction = require("./UnicodeConstants.bs.js");

function string_of_operator(param) {
  switch (param) {
    case /* Arrow */0 :
        return UnicodeConstants$Extraction.typeArrowSym;
    case /* Prod */1 :
        return ",";
    case /* Sum */2 :
        return "|";
    
  }
}

function is_Prod(param) {
  return param === 1;
}

function get_prod_elements(skel) {
  if (skel.tag && skel[1] === 1) {
    return Pervasives.$at(get_prod_elements(skel[2]), get_prod_elements(skel[3]));
  } else {
    return /* :: */[
            skel,
            /* [] */0
          ];
  }
}

function unwrap_parentheses(operand) {
  if (typeof operand === "number" || operand.tag) {
    return OpSeq$Extraction.wrap(operand);
  } else {
    return operand[0];
  }
}

function contract(ty) {
  var mk_seq_operand = function (op, a, b) {
    var skel_002 = /* Placeholder */Block.__(0, [0]);
    var skel_003 = /* Placeholder */Block.__(0, [1]);
    var skel = /* BinOp */Block.__(1, [
        /* NotInHole */0,
        op,
        skel_002,
        skel_003
      ]);
    var seq = Seq$Extraction.mk(a, /* :: */[
          /* tuple */[
            op,
            b
          ],
          /* [] */0
        ]);
    return /* Parenthesized */Block.__(0, [/* OpSeq */[
                skel,
                seq
              ]]);
  };
  var contract_to_operand = function (param) {
    if (typeof param === "number") {
      switch (param) {
        case /* Hole */0 :
            return /* Parenthesized */Block.__(0, [OpSeq$Extraction.wrap(/* Hole */0)]);
        case /* Unit */1 :
            return /* Parenthesized */Block.__(0, [OpSeq$Extraction.wrap(/* Unit */1)]);
        case /* Num */2 :
            return /* Parenthesized */Block.__(0, [OpSeq$Extraction.wrap(/* Num */2)]);
        case /* Bool */3 :
            return /* Parenthesized */Block.__(0, [OpSeq$Extraction.wrap(/* Bool */3)]);
        
      }
    } else {
      switch (param.tag | 0) {
        case /* Arrow */0 :
            return mk_seq_operand(/* Arrow */0, contract_to_operand(param[0]), contract_to_operand(param[1]));
        case /* Prod */1 :
            return mk_seq_operand(/* Prod */1, contract_to_operand(param[0]), contract_to_operand(param[1]));
        case /* Sum */2 :
            return mk_seq_operand(/* Sum */2, contract_to_operand(param[0]), contract_to_operand(param[1]));
        case /* List */3 :
            return /* List */Block.__(1, [OpSeq$Extraction.wrap(contract_to_operand(param[0]))]);
        
      }
    }
  };
  return unwrap_parentheses(contract_to_operand(ty));
}

function expand_opseq(param) {
  return expand_skel(param[0], param[1]);
}

function expand_skel(skel, seq) {
  if (skel.tag) {
    switch (skel[1]) {
      case /* Arrow */0 :
          var ty1 = expand_skel(skel[2], seq);
          var ty2 = expand_skel(skel[3], seq);
          return /* Arrow */Block.__(0, [
                    ty1,
                    ty2
                  ]);
      case /* Prod */1 :
          var ty1$1 = expand_skel(skel[2], seq);
          var ty2$1 = expand_skel(skel[3], seq);
          return /* Prod */Block.__(1, [
                    ty1$1,
                    ty2$1
                  ]);
      case /* Sum */2 :
          var ty1$2 = expand_skel(skel[2], seq);
          var ty2$2 = expand_skel(skel[3], seq);
          return /* Sum */Block.__(2, [
                    ty1$2,
                    ty2$2
                  ]);
      
    }
  } else {
    return expand_operand(Seq$Extraction.nth_operand(skel[0], seq));
  }
}

function expand_operand(param) {
  if (typeof param === "number") {
    switch (param) {
      case /* Hole */0 :
          return /* Hole */0;
      case /* Unit */1 :
          return /* Unit */1;
      case /* Num */2 :
          return /* Num */2;
      case /* Bool */3 :
          return /* Bool */3;
      
    }
  } else if (param.tag) {
    return /* List */Block.__(3, [expand_opseq(param[0])]);
  } else {
    return expand_opseq(param[0]);
  }
}

var expand = expand_opseq;

exports.string_of_operator = string_of_operator;
exports.is_Prod = is_Prod;
exports.get_prod_elements = get_prod_elements;
exports.unwrap_parentheses = unwrap_parentheses;
exports.contract = contract;
exports.expand = expand;
exports.expand_opseq = expand_opseq;
exports.expand_skel = expand_skel;
exports.expand_operand = expand_operand;
/* No side effect */

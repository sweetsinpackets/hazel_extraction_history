// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';

var Block = require("bs-platform/lib/js/block.js");
var Curry = require("bs-platform/lib/js/curry.js");
var Seq$Extraction = require("./Seq.bs.js");
var MetaVarGen$Extraction = require("./MetaVarGen.bs.js");

function mk(associate, seq) {
  return /* OpSeq */[
          Curry._1(associate, seq),
          seq
        ];
}

function wrap(operand) {
  return /* OpSeq */[
          /* Placeholder */Block.__(0, [0]),
          /* S */[
            operand,
            /* E */0
          ]
        ];
}

function get_err_status(get_err_status_operand, opseq) {
  var match = opseq[0];
  if (match.tag) {
    return match[0];
  } else {
    return Curry._1(get_err_status_operand, Seq$Extraction.nth_operand(match[0], opseq[1]));
  }
}

function set_err_status(set_err_status_operand, err, opseq) {
  var skel = opseq[0];
  if (skel.tag) {
    return /* OpSeq */[
            /* BinOp */Block.__(1, [
                err,
                skel[1],
                skel[2],
                skel[3]
              ]),
            opseq[1]
          ];
  } else {
    var seq = opseq[1];
    var n = skel[0];
    var set_operand = Curry._2(set_err_status_operand, err, Seq$Extraction.nth_operand(n, seq));
    var set_seq = Seq$Extraction.update_nth_operand(n, set_operand, seq);
    return /* OpSeq */[
            skel,
            set_seq
          ];
  }
}

function make_inconsistent(make_inconsistent_operand, u_gen, opseq) {
  var skel = opseq[0];
  var op;
  var skel1;
  var skel2;
  if (skel.tag) {
    var match = skel[0];
    if (match && !match[0]) {
      return /* tuple */[
              opseq,
              u_gen
            ];
    } else {
      op = skel[1];
      skel1 = skel[2];
      skel2 = skel[3];
    }
  } else {
    var seq = opseq[1];
    var n = skel[0];
    var match$1 = Curry._2(make_inconsistent_operand, u_gen, Seq$Extraction.nth_operand(n, seq));
    var set_seq = Seq$Extraction.update_nth_operand(n, match$1[0], seq);
    return /* tuple */[
            /* OpSeq */[
              skel,
              set_seq
            ],
            match$1[1]
          ];
  }
  var match$2 = MetaVarGen$Extraction.next(u_gen);
  var set_skel_000 = /* InHole */[
    /* TypeInconsistent */0,
    match$2[0]
  ];
  var set_skel = /* BinOp */Block.__(1, [
      set_skel_000,
      op,
      skel1,
      skel2
    ]);
  return /* tuple */[
          /* OpSeq */[
            set_skel,
            opseq[1]
          ],
          match$2[1]
        ];
}

exports.mk = mk;
exports.wrap = wrap;
exports.get_err_status = get_err_status;
exports.set_err_status = set_err_status;
exports.make_inconsistent = make_inconsistent;
/* No side effect */

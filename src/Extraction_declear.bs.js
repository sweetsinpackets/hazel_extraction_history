// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';

var Block = require("bs-platform/lib/js/block.js");

function option_string_concat(strs) {
  if (strs) {
    var a = strs[0];
    var match = option_string_concat(strs[1]);
    if (a !== undefined && match !== undefined) {
      return a + match;
    } else {
      return ;
    }
  } else {
    return "";
  }
}

function indent_space(level) {
  if (level > 0) {
    return "  " + indent_space(level - 1 | 0);
  } else {
    return "";
  }
}

function pass_eq(_type1, _type2) {
  while(true) {
    var type2 = _type2;
    var type1 = _type1;
    if (typeof type1 === "number") {
      switch (type1) {
        case /* Bool */0 :
            if (typeof type2 === "number") {
              return type2 === 0;
            } else {
              return false;
            }
        case /* Number */1 :
            if (typeof type2 === "number") {
              return type2 === 1;
            } else {
              return false;
            }
        case /* Unit */2 :
            if (typeof type2 === "number") {
              return type2 === 2;
            } else {
              return false;
            }
        case /* CANNOT_INFER */3 :
        case /* CONFLICT */4 :
            return false;
        
      }
    } else if (type1.tag) {
      if (typeof type2 === "number" || !(type2.tag === /* APP */1 && pass_eq(type1[0], type2[0]))) {
        return false;
      } else {
        _type2 = type2[1];
        _type1 = type1[1];
        continue ;
      }
    } else if (typeof type2 === "number" || type2.tag) {
      return false;
    } else {
      _type2 = type2[0];
      _type1 = type1[0];
      continue ;
    }
  };
}

function pass_check(type1, type2) {
  if (typeof type1 === "number") {
    switch (type1) {
      case /* Bool */0 :
          if (typeof type2 === "number") {
            if (type2 !== 3) {
              if (type2 !== 0) {
                return /* CONFLICT */4;
              } else {
                return /* Bool */0;
              }
            }
            
          } else {
            return /* CONFLICT */4;
          }
          break;
      case /* Number */1 :
          if (typeof type2 === "number") {
            switch (type2) {
              case /* Number */1 :
                  return /* Number */1;
              case /* Unit */2 :
                  return /* CONFLICT */4;
              case /* CANNOT_INFER */3 :
                  break;
              default:
                return /* CONFLICT */4;
            }
          } else {
            return /* CONFLICT */4;
          }
          break;
      case /* Unit */2 :
          if (typeof type2 === "number" && type2 >= 2) {
            switch (type2 - 2 | 0) {
              case /* Bool */0 :
                  return /* Unit */2;
              case /* Number */1 :
                  break;
              case /* Unit */2 :
                  return /* CONFLICT */4;
              
            }
          } else {
            return /* CONFLICT */4;
          }
          break;
      case /* CANNOT_INFER */3 :
          return /* CANNOT_INFER */3;
      case /* CONFLICT */4 :
          break;
      
    }
  } else if (type1.tag) {
    if (typeof type2 === "number") {
      if (type2 !== /* CANNOT_INFER */3) {
        return /* CONFLICT */4;
      }
      
    } else if (type2.tag === /* APP */1 && pass_eq(type1, type2)) {
      return type1;
    } else {
      return /* CONFLICT */4;
    }
  } else {
    var a = type1[0];
    if (typeof type2 === "number") {
      if (type2 !== /* CANNOT_INFER */3) {
        return /* CONFLICT */4;
      }
      
    } else if (type2.tag || !pass_eq(a, type2[0])) {
      return /* CONFLICT */4;
    } else {
      return /* List */Block.__(0, [a]);
    }
  }
  if (typeof type2 === "number" && type2 === 3) {
    return /* CANNOT_INFER */3;
  } else {
    return /* CONFLICT */4;
  }
}

function pass_trans(type1) {
  if (typeof type1 === "number") {
    switch (type1) {
      case /* Bool */0 :
          return "bool";
      case /* Number */1 :
          return "int";
      case /* Unit */2 :
          return "()";
      case /* CANNOT_INFER */3 :
      case /* CONFLICT */4 :
          return ;
      
    }
  } else if (type1.tag) {
    return option_string_concat(/* :: */[
                pass_trans(type1[0]),
                /* :: */[
                  " -> ",
                  /* :: */[
                    pass_trans(type1[1]),
                    /* [] */0
                  ]
                ]
              ]);
  } else {
    return option_string_concat(/* :: */[
                pass_trans(type1[0]),
                /* :: */[
                  " list",
                  /* [] */0
                ]
              ]);
  }
}

exports.option_string_concat = option_string_concat;
exports.indent_space = indent_space;
exports.pass_eq = pass_eq;
exports.pass_check = pass_check;
exports.pass_trans = pass_trans;
/* No side effect */

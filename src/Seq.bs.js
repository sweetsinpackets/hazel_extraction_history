// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';

var List = require("bs-platform/lib/js/list.js");
var Pervasives = require("bs-platform/lib/js/pervasives.js");
var OptUtil$Extraction = require("./OptUtil.bs.js");
var ListUtil$Extraction = require("./ListUtil.bs.js");
var Caml_builtin_exceptions = require("bs-platform/lib/js/caml_builtin_exceptions.js");

function mk_affix(op_pairs) {
  if (op_pairs) {
    var match = op_pairs[0];
    return /* A */[
            match[0],
            /* S */[
              match[1],
              mk_affix(op_pairs[1])
            ]
          ];
  } else {
    return /* E */0;
  }
}

function mk(hd, tl) {
  return /* S */[
          hd,
          mk_affix(tl)
        ];
}

function rev(seq) {
  var rev_t = function (rev, seq) {
    var rev$1 = /* S */[
      seq[0],
      rev
    ];
    var affix = seq[1];
    if (affix) {
      return rev_t(/* A */[
                  affix[0],
                  rev$1
                ], affix[1]);
    } else {
      return rev$1;
    }
  };
  return rev_t(/* E */0, seq);
}

function affix_affix(affix1, affix2) {
  if (affix1) {
    var match = affix1[1];
    return /* A */[
            affix1[0],
            /* S */[
              match[0],
              affix_affix(match[1], affix2)
            ]
          ];
  } else {
    return affix2;
  }
}

function seq_op_seq(seq1, op, seq2) {
  return /* S */[
          seq1[0],
          affix_affix(seq1[1], /* A */[
                op,
                seq2
              ])
        ];
}

function affix_seq(prefix, seq) {
  if (prefix) {
    return seq_op_seq(rev(prefix[1]), prefix[0], seq);
  } else {
    return seq;
  }
}

function seq_affix(seq, suffix) {
  if (suffix) {
    return seq_op_seq(seq, suffix[0], suffix[1]);
  } else {
    return seq;
  }
}

function length(param) {
  return 1 + length_of_affix(param[1]) | 0;
}

function length_of_affix(param) {
  if (param) {
    return length(param[1]);
  } else {
    return 0;
  }
}

function nth_operand(n, seq) {
  var match = n === 0;
  if (match) {
    return seq[0];
  } else {
    return nth_operand_of_affix(n - 1 | 0, seq[1]);
  }
}

function nth_operand_of_affix(n, affix) {
  if (affix) {
    return nth_operand(n, affix[1]);
  } else {
    throw [
          Caml_builtin_exceptions.invalid_argument,
          "Seq.nth_operand_of_affix"
        ];
  }
}

function operands_in_range(param, seq) {
  return List.map((function (n) {
                return nth_operand(n, seq);
              }), ListUtil$Extraction.range(param[0], param[1] + 1 | 0));
}

function operands(param) {
  return /* :: */[
          param[0],
          operands_of_affix(param[1])
        ];
}

function operands_of_affix(param) {
  if (param) {
    return operands(param[1]);
  } else {
    return /* [] */0;
  }
}

function operators(param) {
  return operators_of_affix(param[1]);
}

function operators_of_affix(param) {
  if (param) {
    return /* :: */[
            param[0],
            operators(param[1])
          ];
  } else {
    return /* [] */0;
  }
}

function opt_update_nth_operand(n, operand, seq) {
  if (n < 0 || n >= length(seq)) {
    return ;
  } else if (n !== 0) {
    var hd = seq[0];
    return OptUtil$Extraction.map((function (affix) {
                  return /* S */[
                          hd,
                          affix
                        ];
                }), opt_update_nth_operand_of_affix(n - 1 | 0, operand, seq[1]));
  } else {
    return /* S */[
            operand,
            seq[1]
          ];
  }
}

function opt_update_nth_operand_of_affix(n, operand, affix) {
  if (affix) {
    var op = affix[0];
    return OptUtil$Extraction.map((function (seq) {
                  return /* A */[
                          op,
                          seq
                        ];
                }), opt_update_nth_operand(n, operand, affix[1]));
  } else {
    return /* E */0;
  }
}

function update_nth_operand(n, operand, seq) {
  var match = opt_update_nth_operand(n, operand, seq);
  if (match !== undefined) {
    return match;
  } else {
    return Pervasives.failwith("update_nth_operand: index out of bounds");
  }
}

function opt_split_nth_operand(n, seq) {
  if (n < 0) {
    return ;
  } else if (n !== 0) {
    var match = seq[1];
    if (match) {
      var op = match[0];
      var hd = seq[0];
      return OptUtil$Extraction.map((function (param) {
                    var match = param[1];
                    return /* tuple */[
                            param[0],
                            /* tuple */[
                              affix_affix(match[0], /* A */[
                                    op,
                                    /* S */[
                                      hd,
                                      /* E */0
                                    ]
                                  ]),
                              match[1]
                            ]
                          ];
                  }), opt_split_nth_operand(n - 1 | 0, match[1]));
    } else {
      return ;
    }
  } else {
    return /* tuple */[
            seq[0],
            /* tuple */[
              /* E */0,
              seq[1]
            ]
          ];
  }
}

function split_nth_operand(n, seq) {
  var match = opt_split_nth_operand(n, seq);
  if (match !== undefined) {
    return match;
  } else {
    throw [
          Caml_builtin_exceptions.invalid_argument,
          "Seq.split_nth_operand"
        ];
  }
}

function opt_split_nth_operator(n, seq) {
  if (n < 0 || !seq[1]) {
    return ;
  } else if (n !== 0) {
    var match = seq[1];
    var op = match[0];
    var hd = seq[0];
    return OptUtil$Extraction.map((function (param) {
                  var match = param[1];
                  return /* tuple */[
                          param[0],
                          /* tuple */[
                            seq_affix(match[0], /* A */[
                                  op,
                                  /* S */[
                                    hd,
                                    /* E */0
                                  ]
                                ]),
                            match[1]
                          ]
                        ];
                }), opt_split_nth_operator(n - 1 | 0, match[1]));
  } else {
    var match$1 = seq[1];
    return /* tuple */[
            match$1[0],
            /* tuple */[
              /* S */[
                seq[0],
                /* E */0
              ],
              match$1[1]
            ]
          ];
  }
}

function split_nth_operator(n, seq) {
  var match = opt_split_nth_operator(n, seq);
  if (match !== undefined) {
    return match;
  } else {
    throw [
          Caml_builtin_exceptions.invalid_argument,
          "Seq.split_nth_operator"
        ];
  }
}

function split_first_and_suffix(seq) {
  var match = split_nth_operand(0, seq);
  return /* tuple */[
          match[0],
          match[1][1]
        ];
}

function split_prefix_and_last(seq) {
  var match = split_nth_operand(length(seq) - 1 | 0, seq);
  return /* tuple */[
          match[1][0],
          match[0]
        ];
}

function t_of_operand_and_surround(operand, param) {
  return affix_seq(param[0], /* S */[
              operand,
              param[1]
            ]);
}

function t_of_operator_and_surround(operator, param) {
  return affix_seq(/* A */[
              operator,
              param[0]
            ], param[1]);
}

exports.mk_affix = mk_affix;
exports.mk = mk;
exports.rev = rev;
exports.affix_affix = affix_affix;
exports.seq_op_seq = seq_op_seq;
exports.affix_seq = affix_seq;
exports.seq_affix = seq_affix;
exports.length = length;
exports.length_of_affix = length_of_affix;
exports.nth_operand = nth_operand;
exports.nth_operand_of_affix = nth_operand_of_affix;
exports.operands_in_range = operands_in_range;
exports.operands = operands;
exports.operands_of_affix = operands_of_affix;
exports.operators = operators;
exports.operators_of_affix = operators_of_affix;
exports.opt_update_nth_operand = opt_update_nth_operand;
exports.opt_update_nth_operand_of_affix = opt_update_nth_operand_of_affix;
exports.update_nth_operand = update_nth_operand;
exports.opt_split_nth_operand = opt_split_nth_operand;
exports.split_nth_operand = split_nth_operand;
exports.opt_split_nth_operator = opt_split_nth_operator;
exports.split_nth_operator = split_nth_operator;
exports.split_first_and_suffix = split_first_and_suffix;
exports.split_prefix_and_last = split_prefix_and_last;
exports.t_of_operand_and_surround = t_of_operand_and_surround;
exports.t_of_operator_and_surround = t_of_operator_and_surround;
/* No side effect */

// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';

var List = require("bs-platform/lib/js/list.js");
var Curry = require("bs-platform/lib/js/curry.js");
var Caml_obj = require("bs-platform/lib/js/caml_obj.js");
var Caml_option = require("bs-platform/lib/js/caml_option.js");
var OptUtil$Extraction = require("./OptUtil.bs.js");
var Caml_builtin_exceptions = require("bs-platform/lib/js/caml_builtin_exceptions.js");

function is_empty(l) {
  return List.length(l) === 0;
}

function range(loOpt, hi) {
  var lo = loOpt !== undefined ? loOpt : 0;
  if (lo >= hi) {
    return /* [] */0;
  } else {
    return /* :: */[
            lo,
            range(lo + 1 | 0, hi)
          ];
  }
}

function sublist(loOpt, hi, xs) {
  var lo = loOpt !== undefined ? loOpt : 0;
  if (lo < 0 || hi > List.length(xs)) {
    throw [
          Caml_builtin_exceptions.invalid_argument,
          "GeneralUtil.sublist"
        ];
  }
  return List.map((function (n) {
                return List.nth(xs, n);
              }), range(lo, hi));
}

function join(sep, xs) {
  if (xs) {
    var xs$1 = xs[1];
    var x = xs[0];
    if (xs$1) {
      return /* :: */[
              x,
              /* :: */[
                sep,
                join(sep, xs$1)
              ]
            ];
    } else {
      return /* :: */[
              x,
              /* [] */0
            ];
    }
  } else {
    return /* [] */0;
  }
}

function opt_zip(xs, ys) {
  if (xs) {
    if (ys) {
      var y = ys[0];
      var x = xs[0];
      return OptUtil$Extraction.map((function (xys) {
                    return /* :: */[
                            /* tuple */[
                              x,
                              y
                            ],
                            xys
                          ];
                  }), opt_zip(xs[1], ys[1]));
    } else {
      return ;
    }
  } else if (ys) {
    return ;
  } else {
    return /* [] */0;
  }
}

function zip(xs, ys) {
  if (xs && ys) {
    return /* :: */[
            /* tuple */[
              xs[0],
              ys[0]
            ],
            zip(xs[1], ys[1])
          ];
  } else {
    return /* [] */0;
  }
}

function unzip(xys) {
  if (xys) {
    var match = xys[0];
    var match$1 = unzip(xys[1]);
    return /* tuple */[
            /* :: */[
              match[0],
              match$1[0]
            ],
            /* :: */[
              match[1],
              match$1[1]
            ]
          ];
  } else {
    return /* tuple */[
            /* [] */0,
            /* [] */0
          ];
  }
}

function replicate(n, e) {
  var _c = n;
  var _xs = /* [] */0;
  while(true) {
    var xs = _xs;
    var c = _c;
    if (c > 0) {
      _xs = /* :: */[
        e,
        xs
      ];
      _c = c - 1 | 0;
      continue ;
    } else {
      return xs;
    }
  };
}

function map_zip(f, xs) {
  return zip(xs, List.map(f, xs));
}

function mapi_zip(f, xs) {
  return zip(xs, List.mapi(f, xs));
}

function drop(_n, _xs) {
  while(true) {
    var xs = _xs;
    var n = _n;
    if (n > 0) {
      if (xs) {
        _xs = xs[1];
        _n = n - 1 | 0;
        continue ;
      } else {
        return /* [] */0;
      }
    } else {
      return xs;
    }
  };
}

function update_nth(n, xs, f) {
  if (xs) {
    if (n !== 0) {
      return /* :: */[
              xs[0],
              update_nth(n - 1 | 0, xs[1], f)
            ];
    } else {
      return /* :: */[
              Curry._1(f, xs[0]),
              xs[1]
            ];
    }
  } else {
    return /* [] */0;
  }
}

function _findmapi(_i, _xs, f) {
  while(true) {
    var xs = _xs;
    var i = _i;
    if (xs) {
      var match = Curry._2(f, i, xs[0]);
      if (match !== undefined) {
        return Caml_option.some(Caml_option.valFromOption(match));
      } else {
        _xs = xs[1];
        _i = i + 1 | 0;
        continue ;
      }
    } else {
      return ;
    }
  };
}

function findmapi(xs, f) {
  return _findmapi(0, xs, f);
}

function filteri(pred, xs) {
  return List.map((function (param) {
                return param[1];
              }), List.filter((function (param) {
                      return Curry._2(pred, param[0], param[1]);
                    }))(List.mapi((function (i, x) {
                        return /* tuple */[
                                i,
                                x
                              ];
                      }), xs)));
}

function any(xs, f) {
  return OptUtil$Extraction.test(List.find_opt(f, xs));
}

function first(xs) {
  return List.nth_opt(xs, 0);
}

function last(xs) {
  var xs$1 = List.rev(xs);
  return List.nth_opt(xs$1, 0);
}

function split_last(xs) {
  var match = List.rev(xs);
  if (match) {
    return /* tuple */[
            List.rev(match[1]),
            match[0]
          ];
  }
  
}

function elem_before(x, _xs) {
  while(true) {
    var xs = _xs;
    if (xs) {
      var match = xs[1];
      if (match) {
        var y2 = match[0];
        if (Caml_obj.caml_equal(x, y2)) {
          return Caml_option.some(xs[0]);
        } else {
          _xs = /* :: */[
            y2,
            match[1]
          ];
          continue ;
        }
      } else {
        return ;
      }
    } else {
      return ;
    }
  };
}

function elem_after(x, _xs) {
  while(true) {
    var xs = _xs;
    if (xs) {
      var match = xs[1];
      if (match) {
        var y2 = match[0];
        if (Caml_obj.caml_equal(x, xs[0])) {
          return Caml_option.some(y2);
        } else {
          _xs = /* :: */[
            y2,
            match[1]
          ];
          continue ;
        }
      } else {
        return ;
      }
    } else {
      return ;
    }
  };
}

function split_at(xs, n) {
  if (xs) {
    var ys = xs[1];
    var y = xs[0];
    if (Caml_obj.caml_equal(y, n)) {
      return /* tuple */[
              /* [] */0,
              ys
            ];
    } else {
      var match = split_at(ys, n);
      return /* tuple */[
              /* :: */[
                y,
                match[0]
              ],
              match[1]
            ];
    }
  } else {
    return /* tuple */[
            /* [] */0,
            /* [] */0
          ];
  }
}

function partition_i(f, xs) {
  var match = List.partition((function (param) {
          return Curry._2(f, param[0], param[1]);
        }), List.mapi((function (i, x) {
              return /* tuple */[
                      i,
                      x
                    ];
            }), xs));
  var match$1 = List.split(match[0]);
  var match$2 = List.split(match[1]);
  return /* tuple */[
          match$1[1],
          match$2[1]
        ];
}

function fold_left_i(f, acc, xs) {
  var ixs = List.mapi((function (i, x) {
          return /* tuple */[
                  i,
                  x
                ];
        }), xs);
  return List.fold_left(f, acc, ixs);
}

function fold_right_i(f, xs, acc) {
  var ixs = List.mapi((function (i, x) {
          return /* tuple */[
                  i,
                  x
                ];
        }), xs);
  return List.fold_right(f, ixs, acc);
}

function cons_opt(n, x) {
  if (x !== undefined) {
    return /* :: */[
            n,
            x
          ];
  }
  
}

function cons_opt2(n1, x1, n2, x2) {
  if (x1 !== undefined) {
    return /* :: */[
            n1,
            x1
          ];
  } else {
    var match = Curry._1(x2, /* () */0);
    if (match !== undefined) {
      return /* :: */[
              n2,
              match
            ];
    } else {
      return ;
    }
  }
}

function cons_opt3(n1, x1, n2, x2, n3, x3) {
  if (x1 !== undefined) {
    return /* :: */[
            n1,
            x1
          ];
  } else {
    var match = Curry._1(x2, /* () */0);
    if (match !== undefined) {
      return /* :: */[
              n2,
              match
            ];
    } else {
      var match$1 = Curry._1(x3, /* () */0);
      if (match$1 !== undefined) {
        return /* :: */[
                n3,
                match$1
              ];
      } else {
        return ;
      }
    }
  }
}

function combos2(xs, ys) {
  return List.flatten(List.map((function (x) {
                    return List.map((function (y) {
                                  return /* tuple */[
                                          x,
                                          y
                                        ];
                                }), ys);
                  }), xs));
}

function combos3(xs, ys, zs) {
  return List.flatten(List.map((function (param) {
                    var y = param[1];
                    var x = param[0];
                    return List.map((function (z) {
                                  return /* tuple */[
                                          x,
                                          y,
                                          z
                                        ];
                                }), zs);
                  }), combos2(xs, ys)));
}

function take_while(p, xs) {
  return List.rev(List.fold_left((function (rev_taken, x) {
                    if (Curry._1(p, x)) {
                      return /* :: */[
                              x,
                              rev_taken
                            ];
                    } else {
                      return rev_taken;
                    }
                  }), /* [] */0, xs));
}

exports.is_empty = is_empty;
exports.range = range;
exports.sublist = sublist;
exports.join = join;
exports.opt_zip = opt_zip;
exports.zip = zip;
exports.unzip = unzip;
exports.replicate = replicate;
exports.map_zip = map_zip;
exports.mapi_zip = mapi_zip;
exports.drop = drop;
exports.update_nth = update_nth;
exports._findmapi = _findmapi;
exports.findmapi = findmapi;
exports.filteri = filteri;
exports.any = any;
exports.first = first;
exports.last = last;
exports.split_last = split_last;
exports.elem_before = elem_before;
exports.elem_after = elem_after;
exports.split_at = split_at;
exports.partition_i = partition_i;
exports.fold_left_i = fold_left_i;
exports.fold_right_i = fold_right_i;
exports.cons_opt = cons_opt;
exports.cons_opt2 = cons_opt2;
exports.cons_opt3 = cons_opt3;
exports.combos2 = combos2;
exports.combos3 = combos3;
exports.take_while = take_while;
/* No side effect */

// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';

var Block = require("bs-platform/lib/js/block.js");
var Pervasives = require("bs-platform/lib/js/pervasives.js");

function uhtyp_translater(t) {
  if (typeof t === "number") {
    switch (t) {
      case /* Hole */0 :
          return ;
      case /* Unit */1 :
          return "()";
      case /* Num */2 :
          return "int";
      case /* Bool */3 :
          return "bool";
      
    }
  } else {
    switch (t.tag | 0) {
      case /* Parenthesized */0 :
          var match = uhtyp_translater(t[0]);
          if (match !== undefined) {
            return "(" + (match + ")");
          } else {
            return ;
          }
      case /* List */1 :
          var match$1 = uhtyp_translater(t[0]);
          if (match$1 !== undefined) {
            return match$1 + " list";
          } else {
            return ;
          }
      case /* OpSeq */2 :
          return ;
      
    }
  }
}

var uhtyp_example = /* Parenthesized */Block.__(0, [/* List */Block.__(1, [/* Num */2])]);

var match = uhtyp_translater(uhtyp_example);

if (match !== undefined) {
  console.log(match);
}

function emptyhole_handler(param) {
  return ;
}

function var_handler(errstatus, varerrstatus, value) {
  if (errstatus || varerrstatus) {
    return ;
  } else {
    return value;
  }
}

function numlit_handler(errstatus, value) {
  if (errstatus) {
    return ;
  } else {
    return String(value);
  }
}

function boollit_handler(errstatus, value) {
  if (errstatus) {
    return ;
  } else {
    return Pervasives.string_of_bool(value);
  }
}

function listnil_handler(errstatus) {
  if (errstatus) {
    return ;
  } else {
    return "[]";
  }
}

function type_handler(t) {
  switch (t.tag | 0) {
    case /* EmptyHole */0 :
        return ;
    case /* Var */1 :
        return var_handler(t[0], t[1], t[2]);
    case /* NumLit */2 :
        return numlit_handler(t[0], t[1]);
    case /* BoolLit */3 :
        return boollit_handler(t[0], t[1]);
    case /* ListNil */4 :
        if (t[0]) {
          return ;
        } else {
          return "[]";
        }
    default:
      return ;
  }
}

function block_handler(block) {
  return type_handler(block[1]);
}

function extraction_caller(block) {
  var match = block_handler(block);
  if (match !== undefined) {
    return match;
  } else {
    return "It's not completed!";
  }
}

var example_let = /* Block */[
  /* :: */[
    /* LetLine */Block.__(1, [
        /* Var */Block.__(2, [
            /* NotInHole */0,
            /* NotInVarHole */0,
            "x"
          ]),
        undefined,
        /* Block */[
          /* [] */0,
          /* NumLit */Block.__(2, [
              /* NotInHole */0,
              3
            ])
        ]
      ]),
    /* [] */0
  ],
  /* Var */Block.__(1, [
      /* NotInHole */0,
      /* NotInVarHole */0,
      "x"
    ])
];

var example_123 = /* Block */[
  /* [] */0,
  /* NumLit */Block.__(2, [
      /* NotInHole */0,
      123
    ])
];

var example_true = /* Block */[
  /* [] */0,
  /* BoolLit */Block.__(3, [
      /* NotInHole */0,
      true
    ])
];

var example_emptyhole = /* Block */[
  /* [] */0,
  /* EmptyHole */Block.__(0, [45])
];

var example_listnil = /* Block */[
  /* [] */0,
  /* ListNil */Block.__(4, [/* NotInHole */0])
];

exports.example_let = example_let;
exports.example_123 = example_123;
exports.example_true = example_true;
exports.example_emptyhole = example_emptyhole;
exports.example_listnil = example_listnil;
exports.uhtyp_translater = uhtyp_translater;
exports.uhtyp_example = uhtyp_example;
exports.emptyhole_handler = emptyhole_handler;
exports.var_handler = var_handler;
exports.numlit_handler = numlit_handler;
exports.boollit_handler = boollit_handler;
exports.listnil_handler = listnil_handler;
exports.type_handler = type_handler;
exports.block_handler = block_handler;
exports.extraction_caller = extraction_caller;
/* match Not a pure module */

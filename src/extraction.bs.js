// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';

var Block = require("bs-platform/lib/js/block.js");
var Pervasives = require("bs-platform/lib/js/pervasives.js");

function uhtyp_op_translater(op) {
  switch (op) {
    case /* Arrow */0 :
        return " -> ";
    case /* Prod */1 :
        return " * ";
    case /* Sum */2 :
        return " | ";
    
  }
}

function uhtyp_translater(t) {
  if (typeof t === "number") {
    switch (t) {
      case /* Hole */0 :
          return ;
      case /* Unit */1 :
          return "()";
      case /* Num */2 :
          return "int";
      case /* Bool */3 :
          return "bool";
      
    }
  } else {
    switch (t.tag | 0) {
      case /* Parenthesized */0 :
          var match = uhtyp_translater(t[0]);
          if (match !== undefined) {
            return "(" + (match + ")");
          } else {
            return ;
          }
      case /* List */1 :
          var match$1 = uhtyp_translater(t[0]);
          if (match$1 !== undefined) {
            return match$1 + " list";
          } else {
            return ;
          }
      case /* OpSeq */2 :
          var skel_t = t[0];
          if (skel_t.tag && !skel_t[0]) {
            return opseq_handler(t[1]);
          } else {
            return ;
          }
      
    }
  }
}

function opseq_handler(opseq) {
  if (opseq.tag) {
    var match = opseq_handler(opseq[0]);
    var match$1 = uhtyp_translater(opseq[2]);
    if (match !== undefined && match$1 !== undefined) {
      return match + (" " + (uhtyp_op_translater(opseq[1]) + (" " + match$1)));
    } else {
      return ;
    }
  } else {
    var match$2 = uhtyp_translater(opseq[0]);
    var match$3 = uhtyp_translater(opseq[2]);
    if (match$2 !== undefined && match$3 !== undefined) {
      return match$2 + (" " + (uhtyp_op_translater(opseq[1]) + (" " + match$3)));
    } else {
      return ;
    }
  }
}

var uhtyp_example2 = /* Parenthesized */Block.__(0, [/* OpSeq */Block.__(2, [
        /* BinOp */Block.__(1, [
            /* NotInHole */0,
            /* Arrow */0,
            /* BinOp */Block.__(1, [
                /* NotInHole */0,
                /* Arrow */0,
                /* Placeholder */Block.__(0, [0]),
                /* Placeholder */Block.__(0, [1])
              ]),
            /* Placeholder */Block.__(0, [2])
          ]),
        /* SeqOpExp */Block.__(1, [
            /* ExpOpExp */Block.__(0, [
                /* Unit */1,
                /* Arrow */0,
                /* Bool */3
              ]),
            /* Arrow */0,
            /* Num */2
          ])
      ])]);

var match = uhtyp_translater(uhtyp_example2);

if (match !== undefined) {
  console.log(match);
}

function emptyhole_handler(param) {
  return ;
}

function var_handler(errstatus, varerrstatus, value) {
  if (errstatus || varerrstatus) {
    return ;
  } else {
    return value;
  }
}

function numlit_handler(errstatus, value) {
  if (errstatus) {
    return ;
  } else {
    return String(value);
  }
}

function boollit_handler(errstatus, value) {
  if (errstatus) {
    return ;
  } else {
    return Pervasives.string_of_bool(value);
  }
}

function listnil_handler(errstatus) {
  if (errstatus) {
    return ;
  } else {
    return "[]";
  }
}

function type_handler(t) {
  switch (t.tag | 0) {
    case /* EmptyHole */0 :
        return ;
    case /* Var */1 :
        return var_handler(t[0], t[1], t[2]);
    case /* NumLit */2 :
        return numlit_handler(t[0], t[1]);
    case /* BoolLit */3 :
        return boollit_handler(t[0], t[1]);
    case /* ListNil */4 :
        if (t[0]) {
          return ;
        } else {
          return "[]";
        }
    default:
      return ;
  }
}

function block_handler(block) {
  return type_handler(block[1]);
}

function extraction_caller(block) {
  var match = block_handler(block);
  if (match !== undefined) {
    return match;
  } else {
    return "It's not completed!";
  }
}

var example_let = /* Block */[
  /* :: */[
    /* LetLine */Block.__(1, [
        /* Var */Block.__(2, [
            /* NotInHole */0,
            /* NotInVarHole */0,
            "x"
          ]),
        undefined,
        /* Block */[
          /* [] */0,
          /* NumLit */Block.__(2, [
              /* NotInHole */0,
              3
            ])
        ]
      ]),
    /* [] */0
  ],
  /* Var */Block.__(1, [
      /* NotInHole */0,
      /* NotInVarHole */0,
      "x"
    ])
];

var example_123 = /* Block */[
  /* [] */0,
  /* NumLit */Block.__(2, [
      /* NotInHole */0,
      123
    ])
];

var example_true = /* Block */[
  /* [] */0,
  /* BoolLit */Block.__(3, [
      /* NotInHole */0,
      true
    ])
];

var example_emptyhole = /* Block */[
  /* [] */0,
  /* EmptyHole */Block.__(0, [45])
];

var example_listnil = /* Block */[
  /* [] */0,
  /* ListNil */Block.__(4, [/* NotInHole */0])
];

var uhtyp_example1 = /* Parenthesized */Block.__(0, [/* OpSeq */Block.__(2, [
        /* BinOp */Block.__(1, [
            /* NotInHole */0,
            /* Arrow */0,
            /* Placeholder */Block.__(0, [1]),
            /* Placeholder */Block.__(0, [2])
          ]),
        /* ExpOpExp */Block.__(0, [
            /* Num */2,
            /* Arrow */0,
            /* Num */2
          ])
      ])]);

exports.example_let = example_let;
exports.example_123 = example_123;
exports.example_true = example_true;
exports.example_emptyhole = example_emptyhole;
exports.example_listnil = example_listnil;
exports.uhtyp_op_translater = uhtyp_op_translater;
exports.uhtyp_translater = uhtyp_translater;
exports.opseq_handler = opseq_handler;
exports.uhtyp_example1 = uhtyp_example1;
exports.uhtyp_example2 = uhtyp_example2;
exports.emptyhole_handler = emptyhole_handler;
exports.var_handler = var_handler;
exports.numlit_handler = numlit_handler;
exports.boollit_handler = boollit_handler;
exports.listnil_handler = listnil_handler;
exports.type_handler = type_handler;
exports.block_handler = block_handler;
exports.extraction_caller = extraction_caller;
/* match Not a pure module */
